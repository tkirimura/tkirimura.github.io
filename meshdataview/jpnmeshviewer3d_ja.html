<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="initial-scale=1, maximum-scale=1,user-scalable=no" />
<title>MeshDataView3D</title>

<link rel="stylesheet" href="https://js.arcgis.com/4.19/esri/css/main.css">
<style>
      html,
      body {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
      }
      
      #dropcsv {
        line-height: 1.5em;
        padding: 10px;
        border: 4px solid red;
        margin-bottom: 5px;
        font-size: large
      }
      
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
      }
      
      #actions {
        padding: 5px;
        width: 300px;
      }
      
      #displayedfilename, #joinfilename1, #joinfilename2, #numofrecordsjoin1, #numofrecordsjoin2 {
        font-weight: bold;
      }
      
      #numofrecords {
        font-weight: bold;
      }
      
      #numoffields {
        font-weight: bold;
      }
      
      #meshmap-drawing {
        margin-top: 10px;
      }
      
      #titleDiv {
        display: table-cell;
        vertical-align: middle;
        padding: 10px;
      }
      
      .titleString {
        font-weight: bold;
        font-size: x-large;
      }
      
      .widgetlabels {
        display: block;
        margin-top: 5px;
        margin-bottom: 5px;
      }
      
      #howtouseDiv {
        width: 300px;
        height: 300px;
        padding: 10px;
        overflow-y: scroll;
      }
      .htuTitle {
        line-height: 1.5em;
        font-weight: bold;
      }
      .htuContents {
        padding-left: 1em;
      }

      #descriptionDiv {
        width: 300px;
        height: 200px;
        padding: 10px;
        overflow-y: scroll;
      }
      
      #colorRampSelector {
        width: 100%;
        height: 100px;
        overflow-y: scroll;
        padding: 2px;
        border: 1px solid gray;
      }
      #selectedColorRamp {
        width: 100%;
        padding: 2px;
      }
      
      #filteringSlider {
        padding-top: 24px;
        height: 40px;
      }
      
      #filteringSliderNz {
        padding-top: 24px;
        height: 40px;
      }
      
      .screenshotBtnCaption {
        padding: 2px;
        border: 1px solid black;
        display: none;
      }

      #screenshotBtnDiv {
        width: 32px;
        height: 32px;
        padding: 8px;
        content: url("./screenshot_icon24x24.png");
      }
      
      #screenshotBtnDiv:hover {
        cursor: pointer;
        background-color: whitesmoke;
      }
      
      #exportDiv {
        padding: 5px;
        width: 300px;
      }
      
      .flex-container {
        height: 100%;
        display: flex;
        overflow: hidden;
      }
      
      #sidePanelDiv {
        overflow: auto;
        display: none;
        padding: 5px;
        width: 400px;
        font-size: small;
      }

      #dropcsv1,#dropcsv2 {
        line-height: 1.5em;
        padding: 10px;
        border: 4px solid red;
        margin-bottom: 5px;
        font-size: large;
        width: 290px;
        background-color: gray;
      }
      
      #showSidePanelBtn {
        margin-left: 5px;
      }
      
      #exportDivDisplayedData {
        display: inline;
      }

      #exportDivLoadedData {
        display: none;
      }
      
      .widgetlabelTitle {
        font-weight: bold;
      }
      
</style>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.0.0-rc.7/dist/html2canvas.min.js"></script>
<script src="https://js.arcgis.com/4.19/"></script>

</head>
<body>
  <div class="flex-container">
    <div id="viewDiv">
    </div>
    <div id="sidePanelDiv">
      <label class="widgetlabels widgetlabelTitle">ファイルの結合</label>
      <label class="widgetlabels widgetlabelTitle">メッシュデータ1</label>
      <span class="esri-button" id="dropcsv1" ondragover="onDragOverDropBtn(event)" onclick="selectFileDialog(1)">ファイルをドロップ or 選択
        <input type="file" id="selectcsv1" onchange="loadJoinFile(event, 'select', 1)" hidden>
      </span>
      <label class="widgetlabels">ファイル名: <br><span id="joinfilename1"></span></label>
      <label class="widgetlabels">レコード数: <span id="numofrecordsjoin1"></span></label>
      <label class="widgetlabels"><input type="checkbox" id="estatdatajoin1" style="vertical-align: middle;" onclick="fieldRefreshJoin(1)"> e-Statデータ</label>
      <label class="widgetlabels">メッシュコードのフィールド: <br>
        <select name="meshfield" id="fieldlistjoin1">
        </select>
      </label>
      <label class="widgetlabels widgetlabelTitle">メッシュデータ2</label>
      <span class="esri-button" id="dropcsv2" ondragover="onDragOverDropBtn(event)" onclick="selectFileDialog(2)">ファイルをドロップ or 選択
        <input type="file" id="selectcsv2" onchange="loadJoinFile(event, 'select', 2)" hidden>
      </span>
      <label class="widgetlabels">ファイル名: <br><span id="joinfilename2"></span></label>
      <label class="widgetlabels">レコード数: <span id="numofrecordsjoin2"></span></label>
      <label class="widgetlabels"><input type="checkbox" id="estatdatajoin2" style="vertical-align: middle;" onclick="fieldRefreshJoin(2)"> e-Statデータ</label>
      <label class="widgetlabels">メッシュコードのフィールド: <br>
        <select name="meshfield" id="fieldlistjoin2">
        </select>
      </label>
      <label class="widgetlabels"><input type="checkbox" id="joinMethodInner" style="vertical-align: middle;"> 両方に一致するレコードのみ出力</label>
      <button class="esri-button" onclick="joinMeshData()">結合</button>
      <label class="widgetlabels"><span id="messagezonejoin"></span></label>
      <button class="esri-button--tertiary" onclick="hideSidePanel()">閉じる</button>
    </div>
  </div>
    <div id="actions" class="esri-widget">
      <span class="esri-button" id="dropcsv" ondragover="onDragOverDropBtn(event)" onclick="selectFileDialog(3)">ファイルをドロップ or 選択
        <input type="file" id="selectcsv" onchange="loadMappingFile(event, 'select')" multiple hidden>
      </span>
      <label class="widgetlabels"><input type="checkbox" id="adddata" style="vertical-align: middle;" onclick="adddataCheck()"> データの追加読み込み
      <button class="esri-button--secondary" id="showSidePanelBtn" onclick="showSidePanel()">ファイル結合>></button>
      </label>
      <label class="widgetlabels"><input type="checkbox" id="tkycoordinatesystems" style="vertical-align: middle;"> 旧測地系メッシュ</label>
      <label class="widgetlabels">ファイル名: <br><span id="displayedfilename"></span></label>
      <label class="widgetlabels">レコード数: <span id="numofrecords"></span></label>
      <label class="widgetlabels">フィールド数: <span id="numoffields"></span></label>
      <label class="widgetlabels"><input type="checkbox" id="estatdata" style="vertical-align: middle;" onclick="fieldRefresh()"> e-Statデータ</label>
      <label class="widgetlabels">メッシュコードのフィールド: <br>
        <select name="meshfield" id="fieldlist1">
        </select>
      </label>
      <label class="widgetlabels">値のフィールド: <br>
        <select name="valuefield" id="fieldlist2" onchange="clearActionPanelSettings()">
        </select>
      </label>
      <label class="widgetlabels">正規化フィールド (オプション): <br>
        <select name="nzfield" id="fieldlist3" onchange="clearActionPanelSettingsNz()">
        </select>
      </label>
      <label class="widgetlabels">描画方法: <br>
        <select name="rmethod" id="rmethodlist" onchange="selectRenderingMethod()">
          <option value="0">ポイント（大きさ） -- 等間隔</option>
          <option value="1">ポイント（大きさ） -- 自然分類</option>
          <option value="2">ポイント（大きさ） -- 等量分類</option>
          <option value="3">ポイント（大きさ） -- 標準偏差</option>
          <option value="4">ポイント（色） -- 等間隔</option>
          <option value="5">ポイント（色）-- 自然分類</option>
          <option value="6">ポイント（色） -- 等量分類</option>
          <option value="7">ポイント（色）-- 標準偏差</option>
          <option value="8">ポリゴン -- 等間隔</option>
          <option value="9">ポリゴン -- 自然分類</option>
          <option value="10">ポリゴン -- 等量分類</option>
          <option value="11">ポリゴン -- 標準偏差</option>
          <option value="12">3Dポリゴン</option>
        </select>
      </label>
      <label class="widgetlabels" id="colorOptionUI">配色:</label>
      <div id="selectedColorRamp"></div>
      <div id="colorRampSelector"></div>
      <div id="filteringUI">
      <label class="widgetlabels">
      <input type="checkbox" id="chkboxFiltering" style="vertical-align: middle;" onclick="checkFilterFlag()">値で絞り込み<br>
      <button id="calcMinMaxBtn" class="esri-button--secondary" onclick="calculateMinMaxValues()" style="width: 80%; margin-left: 20px;" disabled>最小値・最大値を計算</button></label>
      </div>
      <div id="filteringSlider">
      </div>
      <div id="filteringNzUI">
      <label class="widgetlabels">
      <input type="checkbox" id="chkboxFilteringNz" style="vertical-align: middle;" onclick="checkNzFilterFlag()">正規化フィールドの値で絞り込み<br>
      <button id="calcNzMinMaxBtn" class="esri-button--secondary" onclick="calculateNzMinMaxValues()" style="width: 80%; margin-left: 20px;" disabled>最小値・最大値を計算</button></label>
      </div>
      <div id="filteringSliderNz">
      </div>
      <label class="widgetlabels"><span id="estimatefeaturecount"></span></label>
      <label class="widgetlabels"><span>タイトル: </span><input type="text" class="modifier-class" id="maptitle"></label>
      <button class="esri-button" id="meshmap-drawing">メッシュマップ描画</button>
      <label class="widgetlabels"><span id="messagezone"></span></label>
      <button class="esri-button--tertiary" id="closeActionPanelBtn" onclick="closeActionPanel()"></button>
    </div>
    <div id="legendDiv" class="esri-widget"></div>
    <div id="attributionDiv" class="esri-widget"></div>
    <div id="screenshotBtnDiv" class="esri-widget"></div>
    <div id="exportDiv" class="esri-widget">
     <label class="widgetlabels widgetlabelTitle">エクスポート対象: 
      <select name="exportTypeSelect" id="exportTypeSelect" onchange="changeExportPanel()">
       <option value="displayeddata" selected>表示データ</option>
       <option value="loadeddata">読み込みデータ</option>
      </select>
     </label>
     <div id="exportDivDisplayedData">
      <label class="widgetlabels widgetlabelTitle">表示データのCSVへのエクスポート</label>
      <label class="widgetlabels">1. ポリゴンを描いて出力するフィーチャを選択します:</label>
      <button class="esri-widget--button esri-icon-polygon" id="drawQueryPolygonBtn" style="margin-left: 8px; margin-right: 8px; width: 274px;">ポリゴン描画</button>
      <label class="widgetlabels">2. 出力するフィールドを選びます:</label>
       <input type="radio" name="exportFieldSetting" id="exportFieldDisplayed" value="displayed" checked>表示フィールドのみ
       <input type="radio" name="exportFieldSetting" id="exportFieldAll" value="allfields">全フィールド
      <label class="widgetlabels">3. UTF-8の保存オプションを選びます:</label>
       <input type="radio" name="exportEncodingSetting" id="exportUTF8BOM" value="encutfb" checked>UTF-8 (BOM付き)
       <input type="radio" name="exportEncodingSetting" id="exportUTF8" value="encutf">UTF-8 (BOMなし)
      <label class="widgetlabels">4. ファイル名を入力します:</label>
       <label class="widgetlabels"><input type="text" id="exportFileNameText" style="margin-left: 8px; margin-right: 8px; width: 274px;"></label>
      <button class="esri-button" id="fileExportBtn">CSVファイル出力</button>
     </div>
     <div id="exportDivLoadedData">
      <label class="widgetlabels widgetlabelTitle">読み込みデータのCSVへのエクスポート</label>
      <label class="widgetlabels" style="color: red;">描画設定の絞り込みオプションは反映されません.</label>
      <label class="widgetlabels">1. UTF-8の保存オプションを選びます:</label>
       <input type="radio" name="exportEncodingSettingLoadedData" id="exportUTF8BOMLoadedData" value="encutfb" checked>UTF-8 (BOM付き)
       <input type="radio" name="exportEncodingSettingLoadedData" id="exportUTF8LoadedData" value="encutf">UTF-8 (BOMなし)
      <label class="widgetlabels">2. ファイル名を入力します:</label>
       <label class="widgetlabels"><input type="text" id="exportFileNameTextLoadedData" style="margin-left: 8px; margin-right: 8px; width: 274px;"></label>
      <button class="esri-button" id="fileExportBtnLoadedData">CSVファイル出力</button>
     </div>
    </div>
    <div id="titleDiv" class="esri-widget"><span class="titleString">MeshDataView3D</span> by <a href="https://tkirimura.github.io/" target="_blank">Takashi Kirimura</a></div>
    <div id="howtouseDiv" class="esri-widget">
    <span class="htuTitle">MeshDataView3Dの使い方</span>
    <span>
    <ol type="1" class="htuContents">
    <li>用意したメッシュデータ（txtまたはcsv. 複数ファイル可）を右上の赤枠の<strong>'ここにファイルをドロップ'</strong>にドロップします.<br>
      <img src="./image_01.png"><br>
      <a href="https://tkirimura.github.io/meshdataview/sample_meshdata_census2015_tab2.csv">サンプルデータ</a>もあります.</li>
    <li>もし、e-Statからファイルをダウンロードした場合は、<strong>'e-Stat データ'</strong>にチェックします.</li>
    <li><strong>メッシュコードのフィールド</strong>を選びます.</li>
    <li><strong>値のフィールド</strong>を選びます.</li>
    <li>必要に応じて<strong>正規化フィールド</strong>を選びます.</li>
    <li><strong>描画方法</strong>を選びます. 大きさと色は<strong>ポイント</strong>で描画され、ポリゴンは<strong>ポリゴン</strong>で描画されます. <strong>3Dポリゴン</strong>では、値または正規化フィールドの値をもとに3次元で表示されます.</li>
    <li>もし、<strong>'色'</strong>または<strong>'ポリゴン'</strong>を描画方法で選んだ場合、<strong>配色</strong>を選ぶことができます.</li>
    <li>もし、左下の凡例ボックスのタイトルが必要なら、<strong>タイトル</strong>を修正できます.</li>
    <li><strong>'メッシュマップ描画'</strong>をクリックします.</li>
    </ol>
    すでにデータを読み込んでいる場合、<strong>'データの追加読み込み'</strong>にチェックを入れると、ドロップされたデータを既存データに追加できます.<br>
    サンプルデータの出典：e-Stat 地図で見る統計 平成27年国勢調査 4次メッシュ その2<br>
    </span>
    </div>
    <div id="descriptionDiv" class="esri-widget">
    <span class="htuTitle">MeshDataView3D v0.20</span><br>
    <span>
    MeshDataView3Dは、日本の地域メッシュ単位の統計データを可視化できます. <br>3次・4次・5次メッシュのコードがあるデータであれば、<a href="https://www.e-stat.go.jp/gis" target="_blank">e-Stat</a>や他で作成した、カンマ区切りのCSVやTXTファイルを読み込むことができます. 詳細な解説は<a href="https://arcg.is/1OC9Li" target="_blank">こちらのページ</a>にあります.<br>
    </span>
    </div>
<script>

var meshData = [];
var rawData = [];
var fileName = "";
var valueMin = Number.MAX_SAFE_INTEGER;
var valueMax = Number.MIN_SAFE_INTEGER;
var nzValueMin = Number.MAX_SAFE_INTEGER;
var nzValueMax = Number.MIN_SAFE_INTEGER;
var meshcodeFieldNum = 0;
var valueFieldNum = 0;
var nzFieldNum = 0;
var meshType = "tertiary";
var fieldNames = [];
var sSlider,cSlider,cSlider3d;
var renderer3d;
var colorRampFlag = false;
var cScheme;
var calculatedMinMax = false;
var filteringSliderObject;
var filteringSliderObjectNz;
var featuresLoaded = 0; // number of loaded features
var exportObjectIds;
var meshcodeIndex;

// Join Process
var joinRawData1 = [];
var joinRawData2 = [];
var joinFieldNames1 = [];
var joinFieldNames2 = [];
var joinMeshcodeFieldNum1 = 0;
var joinMeshcodeFieldNum2 = 0;


const ACTIONPANELOPEN = "描画設定を開く";
const ACTIONPANELCLOSE = "描画設定を閉じる";
const MESSAGE_FEATURESWILLBELOADED = " フィーチャが読み込まれます.";
const MESSAGE_FEATURESLOADED = " フィーチャが読み込まれました.";
const ALERTNODATA = "データがありません! データを読み込んでください.";
const FILEAPIERRORMESSAGE = "最新版のブラウザを使ってください. このアプリケーションにはFile APIが必要です.";
const EXPANDBASEMAP = "背景地図の選択";
const EXPANDHOWTOUSE = "使い方";
const EXPANDDESCRIPTION = "このツールについて";
const EXPANDEXPORT = "CSVエクスポート";
const CAUTION_OVER50000 = "50,000フィーチャ以上を描画することはできません. 絞り込みオプションを使ってください."
const CAUTION_OVER30000 = "約30,000以上のフィーチャを描画することはできますが、描画が不安定になります. 絞り込みオプションを使ってください. 続けますか？"
const MESSAGE_YES = "<はい>";
const MESSAGE_NO = "<いいえ>";
const CAUTION_NOJOINDATA1 = "メッシュデータ1がありません.";
const CAUTION_NOJOINDATA2 = "メッシュデータ2がありません.";
const CAUTION_CANNOT_LOAD_MULTIPLEFILES_IN_JOIN = "複数ファイルのドロップには対応していません.";
const JOINEDMESSAGE_LOADMAPYESNO = " レコード結合されました.地図に読み込みますか？";
const POPUP_GETADDRESS_BTN = "中心点住所の取得";
const POPUP_ADDRESS_NOTFOUND = "住所を見つけることができませんでした.";


// half of mesh size by decimal degree [x, y]
var meshSize = { "tertiary": [0.375/60.0, 0.25/60.0],
                 "quaternary": [22.5/7200.0, 15.0/7200.0],
                 "quinary": [11.25/7200.0, 7.5/7200.0],
                 "senary": [5.625/7200.0, 3.75/7200.0]};

require([
  "esri/config",
  "esri/Map",
  "esri/views/MapView",
  "esri/views/SceneView",
  "esri/Graphic",
  "esri/layers/FeatureLayer",
  "esri/layers/GraphicsLayer",
  "esri/widgets/Legend",
  "esri/widgets/Attribution",
  "esri/symbols/support/symbolUtils",
  "esri/smartMapping/renderers/size",
  "esri/smartMapping/renderers/color",
  "esri/smartMapping/statistics/histogram",
  "esri/smartMapping/symbology/support/colorRamps",
  "esri/smartMapping/symbology/color",
  "esri/widgets/smartMapping/ClassedSizeSlider",
  "esri/widgets/smartMapping/ClassedColorSlider",
  "esri/widgets/smartMapping/ColorSlider",
  "esri/widgets/BasemapGallery",
  "esri/widgets/Expand",
  "esri/widgets/Compass",
  "esri/widgets/Print",
  "esri/widgets/ScaleBar",
  "esri/widgets/Slider",
  "esri/widgets/Sketch/SketchViewModel",
  "esri/core/promiseUtils",
  "esri/tasks/Locator",
  "esri/geometry/projection",
  "esri/geometry/SpatialReference"
  ], function (
  esriConfig,
  Map,
  MapView,
  SceneView,
  Graphic,
  FeatureLayer,
  GraphicsLayer,
  Legend,
  Attribution,
  symbolUtils,
  sizeRendererCreator,
  colorRendererCreator,
  histogram,
  colorRamps,
  colorSchemes,
  ClassedSizeSlider,
  ClassedColorSlider,
  ColorSlider,
  BasemapGallery,
  Expand,
  Compass,
  Print,
  ScaleBar,
  Slider,
  SketchViewModel,
  promiseUtils,
  Locator,
  projection,
  SpatialReference
  ) {
    const map = new Map({
      basemap: "dark-gray-vector"
    });
    
    const view = new SceneView({
      map: map,
      container: "viewDiv",
      qualityProfile: "high",
      camera: { position: { latitude: 33.8, longitude: 135.2, z: 100000 }, tilt: 45, heading: 15 }
    });
    
    const legend = new Legend({
      view: view,
      container: "legendDiv"
    });
    
    var compassWidget = new Compass({
      view: view
    });
    
    var basemapGallery = new BasemapGallery({
      view: view,
      container: document.createElement("div")
    });
    
    var bgExpand = new Expand({
      view: view,
      content: basemapGallery,
      expandTooltip: EXPANDBASEMAP
    });

    basemapGallery.watch('activeBasemap', function(event) {
      refreshColorRamps();
      bgExpand.collapse();
    });
    

    var howtouseExpand = new Expand({
      expandIconClass: "esri-icon-question",
      view: view,
      content: document.getElementById("howtouseDiv"),
      expandTooltip: EXPANDHOWTOUSE
    });

    var descriptionExpand = new Expand({
      expandIconClass: "esri-icon-description",
      view: view,
      content: document.getElementById("descriptionDiv"),
      expandTooltip: EXPANDDESCRIPTION
    });

    var screenshotBtn = document.getElementById("screenshotBtnDiv");
    screenshotBtn.addEventListener("click", compositScreenshotImage);

    var exportExpand = new Expand({
      expandIconClass: "esri-icon-save",
      view: view,
      content: document.getElementById("exportDiv"),
      expandTooltip: EXPANDEXPORT
    });
    
    // for capture
    var attributionWidget = new Attribution({
      view: view,
      container: "attributionDiv"
    });
    
    view.ui.add("titleDiv", "top-left");
    view.ui.move("zoom", "top-left");
    view.ui.move("navigation-toggle", "top-left");
    view.ui.move("compass", "top-left");
    view.ui.add(bgExpand, "top-left");
    view.ui.add(screenshotBtn, "top-left");
    view.ui.add(exportExpand, "top-left");
    view.ui.add(howtouseExpand, "top-left");
    view.ui.add(descriptionExpand, "top-left");
    
    view.ui.add(document.getElementById("actions"), "top-right");
    view.ui.add(legend, "bottom-left");

    var locatorTask = new Locator({
      url: "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer"
    });
    
    
    

    const drawBtn = document.getElementById("meshmap-drawing");

    drawBtn.addEventListener("click", drawFeaturesCheck);
    
    const meshdataLayer = new FeatureLayer({
      title: "Japan Mesh Data",
      fields: [
        {
          name: "ObjectID",
          alias: "ObjectID",
          type: "oid"
        },
        {
          name: "Meshcode",
          alias: "Meshcode",
          type: "string"
        },
        {
          name: "Longitude",
          alias: "Longitude",
          type: "double"
        },
        {
          name: "Latitude",
          alias: "Latitude",
          type: "double"
        },
        {
          name: "Value",
          alias: "Value",
          type: "double"
        },
        {
          name: "Nzvalue",
          alias: "Nzvalue",
          type: "double"
        }
      ],
      objectIdField: "ObjectID",
      outFields: ["*"],
      geometryType: "point",
      spatialReference: { wkid: 4326 },
      source: [],
      renderer: {
        type: "simple",
        symbol: {
          type: "point-3d",
          styleName: "Esri2DPointSymbolsStyle",
          name: "circle-1"
        }
      },
      legendEnabled: false,
      popupTemplate: {
        title: "Meshcode: {Meshcode}",
        content: "Value: {Value}<br>Normarization Value: {Nzvalue}"
      }
    });
    map.add(meshdataLayer);
    
    meshdataLayer.queryFeatures().then(function(results){
      if (results.features.length === 0){
        drawBtn.disabled = false;
      }
      else {
        drawBtn.disabled = true;
      }
    });

    const meshdataPgLayer = new FeatureLayer({
      title: "Japan Mesh Data",
      fields: [
        {
          name: "ObjectID",
          alias: "ObjectID",
          type: "oid"
        },
        {
          name: "Meshcode",
          alias: "Meshcode",
          type: "string"
        },
        {
          name: "Longitude",
          alias: "Longitude",
          type: "double"
        },
        {
          name: "Latitude",
          alias: "Latitude",
          type: "double"
        },
        {
          name: "Value",
          alias: "Value",
          type: "double"
        },
        {
          name: "Nzvalue",
          alias: "Nzvalue",
          type: "double"
        }
      ],
      objectIdField: "ObjectID",
      outFields: ["*"],
      geometryType: "polygon",
      spatialReference: { wkid: 4326 },
      source: [],
      renderer: {
        type: "simple",
        symbol: {
          type: "simple-fill"
        }
      },
      legendEnabled: false,
      opacity: 0.6,
      popupTemplate: {
        title: "Meshcode: {Meshcode}",
        content: "Value: {Value}<br>Normarization Value: {Nzvalue}"
      }
    });
    
    map.add(meshdataPgLayer);
    
    meshdataPgLayer.queryFeatures().then(function(results){
      if (results.features.length === 0){
        drawBtn.disabled = false;
      }
      else {
        drawBtn.disabled = true;
      }
    });
    
    filteringSliderObject = new Slider({
      container: "filteringSlider",
      min: 0,
      max: 100,
      values: [0, 100],
      snapOnClickEnabled: false,
      visibleElements: {
        labels: true,
        rangeLabels: true
      },
      labelInputsEnabled: true,
      disabled: true
    });
    
    filteringSliderObject.on(["thumb-change", "thumb-drag"], function() {
      var estFeaturesCount = estimateLoadingFeatures();
      var messagespan = document.getElementById("estimatefeaturecount");
      messagespan.innerText = estFeaturesCount.toString() + MESSAGE_FEATURESWILLBELOADED;
    });

    // Slider for normalization value filtering
    filteringSliderObjectNz = new Slider({
      container: "filteringSliderNz",
      min: 0,
      max: 100,
      values: [0, 100],
      snapOnClickEnabled: false,
      visibleElements: {
        labels: true,
        rangeLabels: true
      },
      labelInputsEnabled: true,
      disabled: true
    });
    
    filteringSliderObjectNz.on(["thumb-change", "thumb-drag"], function() {
      var estFeaturesCount = estimateLoadingFeatures();
      var messagespan = document.getElementById("estimatefeaturecount");
      messagespan.innerText = estFeaturesCount.toString() + MESSAGE_FEATURESWILLBELOADED;
    });
    
    
    
    document.getElementById("drawQueryPolygonBtn").addEventListener("click", function() {
      clearSketchGeometry();
      sketchViewModel.create("polygon");
    });
    
    document.getElementById("fileExportBtn").addEventListener("click", function() {
      if (highlightHandle && exportObjectIds.length > 0) {
        saveMeshData();
      }
    });
    
    document.getElementById("fileExportBtnLoadedData").addEventListener("click", function() {
      if (rawData.length > 0) {
        saveLoadedData();
      }
    });
    
    
    view.on("resize", function(event) {
      var actDiv = document.getElementById("actions");
      if ((event.height - actDiv.getBoundingClientRect().height) < 60) {
        var btn = document.getElementById("closeActionPanelBtn");
        if (btn.innerText == ACTIONPANELCLOSE) {
          actDiv.style.overflowY = "scroll";
          actDiv.style.height = (event.height - 60).toString() + "px";
        }
      } else {
        var btn = document.getElementById("closeActionPanelBtn");
        if (btn.innerText == ACTIONPANELCLOSE) {
          actDiv.style.overflowY = "auto";
          actDiv.style.height = "";
        }
      }
    });
    
    
    view.when(function() {
      var actDiv = document.getElementById("actions");
      if ((view.height - actDiv.getBoundingClientRect().height) < 40) {
        var btn = document.getElementById("closeActionPanelBtn");
        btn.click();
      }
    })
    .catch(function(error) { console.log(error); });
    
    
    
    
    
    // query feature by graphics
    let ptLayerView = null;
    let pgLayerView = null;
    
    view.whenLayerView(meshdataLayer).then(function(layerView) {
      ptLayerView = layerView;
    });
    
    view.whenLayerView(meshdataPgLayer).then(function(layerView) {
      pgLayerView = layerView;
    });
    
    const sketchLayer = new GraphicsLayer();
    map.add(sketchLayer);
    
    let sketchGeometry = null;
    const sketchViewModel = new SketchViewModel({
      layer: sketchLayer,
      defaultUpdateOptioins: {
        tool: "reshape",
        toglleToolOnClick: false
      },
      view: view,
      defaultCreateOptions: { hasZ: false }
    });
    
    sketchViewModel.on("create", function(event) {
      if (event.state === "complete") {
        sketchGeometry = event.graphic.geometry;
        runQuery();
      }
    });
    
    sketchViewModel.on("update", function(event) {
      if (event.state === "complete") {
        sketchGeometry = event.graphics[0].geometry;
        runQuery();
      }
    });
    
    function clearSketchGeometry() {
      sketchGeometry = null;
      sketchViewModel.cancel();
      sketchLayer.removeAll();
      clearHighlighting();
    }
    
    var debouncedRunQuery = promiseUtils.debounce(function() {
      if (!sketchGeometry) {
        return;
      }
      return promiseUtils.eachAlways([
        updateScene()
      ]);
    });
    
    function runQuery() {
      debouncedRunQuery().catch((error) => {
        if (error.name === "AbortError") {
          return;
        }
        console.error(error);
      });
    }
    
    var highlightHandle = null;
    function clearHighlighting() {
      if (highlightHandle) {
        highlightHandle.remove();
        highlightHandle = null;
      }
    }
    
    function highlightPolygons(objectIds) {
      clearHighlighting();
      exportObjectIds = objectIds;
      var rendererCode = document.getElementById("rmethodlist").value;
      if (rendererCode < 8) {
        const objectIdField = meshdataLayer.objectIdField;
        highlightHandle = ptLayerView.highlight(objectIds);
      } else {
        const objectIdField = meshdataPgLayer.objectIdField;
        highlightHandle = pgLayerView.highlight(objectIds);
      }
    }
    
    function updateScene() {
      var rendererCode = document.getElementById("rmethodlist").value;
      if (rendererCode < 8) {
        const query = ptLayerView.createQuery();
        query.geometry = sketchGeometry;
        return ptLayerView
          .queryObjectIds(query)
          .then(highlightPolygons);
      } else {
        const query = pgLayerView.createQuery();
        query.geometry = sketchGeometry;
        return pgLayerView
          .queryObjectIds(query)
          .then(highlightPolygons);
      }
    }
    
    function saveMeshData() {
      var rendererCode = document.getElementById("rmethodlist").value;
      
      var exportAllFields = false;
      if (document.getElementById("exportFieldDisplayed").checked) exportAllFields = false;
      if (document.getElementById("exportFieldAll").checked) exportAllFields = true;
      
      var exportEncoding = "";
      if (document.getElementById("exportUTF8BOM").checked) exportEncoding = "utf8b";
      if (document.getElementById("exportUTF8").checked) exportEncoding = "utf8";
      
      var exportFileName = document.getElementById("exportFileNameText").value;
      if (exportFileName == "") exportFileName = "meshdata.csv";
      if (exportFileName.slice(-4).toLowerCase() != ".csv") exportFileName += ".csv";
      
      if (rendererCode < 8) {
        const query = ptLayerView.createQuery();
        query.geometry = sketchGeometry;
        query.returnGeometry = true;
        query.outFields = ["*"];
        return ptLayerView.queryFeatures(query).then(function(result) {
          var exportFeatureCount = result.features.length;
          var textContents = "";
          var newLine = "\n";
          
          // header
          if (exportAllFields) {
            textContents = "MESHCODE,LONGITUDE,LATITUDE";
            for (var n=0; n<fieldNames.length; n++){
              textContents += "," + fieldNames[n].trim();
            }
            textContents += newLine;
          } else {
            var vfieldName = fieldNames[valueFieldNum].trim();
            textContents = "MESHCODE,LONGITUDE,LATITUDE," + vfieldName;
            if (nzFieldNum != -1) {
              var nzfieldName = fieldNames[nzFieldNum].trim();
              textContents += "," + nzfieldName + newLine;
            } else {
              textContents += newLine;
            }
          }
          
          // contents
          for (var i=0; i<exportFeatureCount; i++) {
            var mcode = result.features[i].attributes["Meshcode"];
            textContents += mcode;
            //var latlon = latlonFromMeshcode(mcode);
            var lonx = result.features[i].attributes["Longitude"];
            var laty = result.features[i].attributes["Latitude"];
            //var lonx = latlon.x;
            //var laty = latlon.y;
            textContents += "," + lonx.toString() + "," + laty.toString();
            if (exportAllFields) {
              var idx = meshcodeIndex[mcode];
              var row = rawData[idx].replace(/\r?\n/g,'');
              textContents += "," + row + newLine;
            } else {
              textContents += "," + isNullConvert(result.features[i].attributes["Value"],"");
              if (nzFieldNum != -1) {
                textContents += "," + isNullConvert(result.features[i].attributes["Nzvalue"],"") + newLine;
              } else {
                textContents += newLine;
              }
            }
          }
          
          var blob;
          if (exportEncoding == "utf8b") {
            let utfBOM = new Uint8Array([0xEF, 0xBB, 0xBF]);
            blob = new Blob([utfBOM, textContents], { type: "text/plain", endings: "native" });
          } else {
            blob = new Blob([textContents], { type: "text/plain", endings: "native" });
          }
          let downlink = document.createElement("a");
          clearSketchGeometry();
          downlink.href = URL.createObjectURL(blob);
          downlink.download = exportFileName;
          downlink.click();
        }, console.error);
      } else { 
        const query = pgLayerView.createQuery();
        query.geometry = sketchGeometry;
        query.returnGeometry = true;
        query.outFields = ["*"];
        return pgLayerView.queryFeatures(query).then(function(result) {
          var exportFeatureCount = result.features.length;
          var textContents = "";
          var newLine = "\n";
          
          // header
          if (exportAllFields) {
            textContents = "MESHCODE,LONGITUDE,LATITUDE";
            for (var n=0; n<fieldNames.length; n++){
              textContents += "," + fieldNames[n].trim();
            }
            textContents += newLine;
          } else {
            var vfieldName = fieldNames[valueFieldNum].trim();
            textContents = "MESHCODE,LONGITUDE,LATITUDE," + vfieldName;
            if (nzFieldNum != -1) {
              var nzfieldName = fieldNames[nzFieldNum].trim();
              textContents += "," + nzfieldName + newLine;
            } else {
              textContents += newLine;
            }
          }
          
          // contents
          for (var i=0; i<exportFeatureCount; i++) {
            var mcode = result.features[i].attributes["Meshcode"];
            textContents += mcode;
            var lonx = result.features[i].attributes["Longitude"];
            var laty = result.features[i].attributes["Latitude"];
            textContents += "," + lonx.toString() + "," + laty.toString();
            if (exportAllFields) {
              var idx = meshcodeIndex[mcode];
              var row = rawData[idx].replace(/\r?\n/g,'');
              textContents += "," + row + newLine;
            } else {
              textContents += "," + isNullConvert(result.features[i].attributes["Value"],"");
              if (nzFieldNum != -1) {
                textContents += "," + isNullConvert(result.features[i].attributes["Nzvalue"],"") + newLine;
              } else {
                textContents += newLine;
              }
            }
          }
          
          var blob;
          if (exportEncoding == "utf8b") {
            let utfBOM = new Uint8Array([0xEF, 0xBB, 0xBF]);
            blob = new Blob([utfBOM, textContents], { type: "text/plain", endings: "native" });
          } else {
            blob = new Blob([textContents], { type: "text/plain", endings: "native" });
          }
          let downlink = document.createElement("a");
          clearSketchGeometry();
          downlink.href = URL.createObjectURL(blob);
          downlink.download = exportFileName;
          downlink.click();
        }, console.error);
      }
    }
    
    function saveLoadedData() {
      
      meshcodeFieldNum = document.getElementById("fieldlist1").value;

      var exportEncoding = "";
      if (document.getElementById("exportUTF8BOMLoadedData").checked) exportEncoding = "utf8b";
      if (document.getElementById("exportUTF8LoadedData").checked) exportEncoding = "utf8";
      
      var exportFileName = document.getElementById("exportFileNameTextLoadedData").value;
      if (exportFileName == "") exportFileName = "meshdata.csv";
      if (exportFileName.slice(-4).toLowerCase() != ".csv") exportFileName += ".csv";
      
      var textContents = "";
      var newLine = "\n";
          
      // header
      textContents = "MESHCODE,LONGITUDE,LATITUDE";
      for (var n=0; n<fieldNames.length; n++){
        textContents += "," + fieldNames[n].trim();
      }
      textContents += newLine;
      
      // contents
      var tkyflag = document.getElementById("tkycoordinatesystems");
      if (tkyflag.checked) {
        // tky -> jgd
        projection.load().then(function() {
          var outSR = new SpatialReference({ wkid: 4326 });
          var inSR = new SpatialReference({ wkid: 4301 });
          var trans = projection.getTransformation(inSR, outSR);

          for (var i=1; i<rawData.length; i++) {
            var row = rawData[i].split(/,/);
            var mcode = row[meshcodeFieldNum];

            if (mcode.length >= 8 && parseInt(mcode, 10) > 0) {
              var latlon = latlonFromMeshcode(mcode);
              var lonx, laty;
              lonx = latlon.x;
              laty = latlon.y;
              var graphic = new Graphic({
                geometry: {
                  type: "point",
                  latitude: laty,
                  longitude: lonx,
                  spatialReference: inSR
                }
              });
              var geometry2 = projection.project(graphic.geometry, outSR, trans);

              textContents += mcode;
              textContents += "," + geometry2.x.toString() + "," + geometry2.y.toString();
              textContents += "," + rawData[i].replace(/\r?\n/g,'') + newLine;
            }
          }
          
          var blob;
          if (exportEncoding == "utf8b") {
            let utfBOM = new Uint8Array([0xEF, 0xBB, 0xBF]);
            blob = new Blob([utfBOM, textContents], { type: "text/plain", endings: "native" });
          } else {
            blob = new Blob([textContents], { type: "text/plain", endings: "native" });
          }
          let downlink = document.createElement("a");
          clearSketchGeometry();
          downlink.href = URL.createObjectURL(blob);
          downlink.download = exportFileName;
          downlink.click();
        });
      } else {
        for (var i=1; i<rawData.length; i++) {
          var row = rawData[i].split(/,/);
          var mcode = row[meshcodeFieldNum];

          if (mcode.length >= 8 && parseInt(mcode, 10) > 0) {
            var latlon = latlonFromMeshcode(mcode);
            var lonx, laty;
            lonx = latlon.x;
            laty = latlon.y;

            textContents += mcode;
            textContents += "," + lonx.toString() + "," + laty.toString();
            textContents += "," + rawData[i].replace(/\r?\n/g,'') + newLine;
          }
          
        }
        var blob;
        if (exportEncoding == "utf8b") {
          let utfBOM = new Uint8Array([0xEF, 0xBB, 0xBF]);
          blob = new Blob([utfBOM, textContents], { type: "text/plain", endings: "native" });
        } else {
          blob = new Blob([textContents], { type: "text/plain", endings: "native" });
        }
        let downlink = document.createElement("a");
        clearSketchGeometry();
        downlink.href = URL.createObjectURL(blob);
        downlink.download = exportFileName;
        downlink.click();
      }
    }


    document.getElementById("closeActionPanelBtn").innerText = ACTIONPANELCLOSE;
    
    refreshColorRamps();
    selectRenderingMethod();
    
    
    view.popup.on("trigger-action", function(event) {
      if (event.action.id === "get-address") {
        popupGetAddress();
      }
    });




    
    /*           */
    /* FUNCTIONS */
    /*           */
    
    function isNullConvert(val1, val2) {
      return (val1 == null)?val2:val1;
    }
    
    function drawFeaturesCheck() {
      var fcount = estimateLoadingFeatures();
      
      if (fcount >= 50000) {
        // This viewer cannot draw more than 50,000 features
        var messDiv = document.getElementById("messagezone");
        messDiv.style.color = "red";
        messDiv.innerText = CAUTION_OVER50000;
        return false;
      } else if (fcount >= 30000) {
        // This viewer can draw more than around 30,000 features, but the map may be unstable. Recommend to use filter options.
        var messDiv = document.getElementById("messagezone");
        messDiv.style.color = "red";
        messDiv.innerText = CAUTION_OVER30000;
        var yesMessBtn = document.createElement("button");
        yesMessBtn.classList.add("esri-button--tertiary");
        yesMessBtn.innerText = MESSAGE_YES;
        yesMessBtn.addEventListener("click", function() {
          messDiv.innerHTML = "";
          drawFeatures();
        });
        messDiv.appendChild(yesMessBtn);
        var noMessBtn = document.createElement("button");
        noMessBtn.classList.add("esri-button--tertiary");
        noMessBtn.innerText = MESSAGE_NO;
        noMessBtn.addEventListener("click", function() {
          messDiv.innerHTML = "";
        });
        messDiv.appendChild(noMessBtn);
        return false;
      } else {
        drawFeatures();
      }
    }
    

    function popupGetAddress() {
      var geom = view.popup.selectedFeature.geometry;
      if (geom.type == "point") {
        var paramsLocator = { location: geom };
      } else if (geom.type == "polygon") {
        var centPoi = geom.centroid;
        var paramsLocator = { location: centPoi };
      }
      locatorTask
        .locationToAddress(paramsLocator)
        .then(function(response) {
          if (response.attributes["Type"] == "Country") {
            view.popup.title = view.popup.content.title + "<br>" + POPUP_ADDRESS_NOTFOUND;
          } else {
            var addressStr = response.attributes["Region"]
              + response.attributes["MetroArea"]
              + response.attributes["City"]
              + response.attributes["District"]
              + response.attributes["Neighborhood"];
            view.popup.title = view.popup.content.title + "<br>" + addressStr;
          }
        })
        .catch(function(error) {
          view.popup.title = view.popup.content.title + "<br>" + POPUP_ADDRESS_NOTFOUND;
          console.log(error);
        });
    }
    
    
    function drawFeatures(){
      var rendererCode = document.getElementById("rmethodlist").value;
      clearSketchGeometry();
      if (cSlider) {
        let container1 = document.getElementById("colorSliderDiv");
        view.ui.remove(container1);
        cSlider.container = null;
        cSlider = null;
        container1 = null;
      }
      
      if (cSlider3d) {
        let container3 = document.getElementById("colorSlider3dDiv");
        view.ui.remove(container3);
        cSlider3d.container = null;
        cSlider3d = null;
        container3 = null;
      }

      if (sSlider) {
        let container2 = document.getElementById("sizeSliderDiv");
        view.ui.remove(container2);
        sSlider.container = null;
        sSlider = null;
        container2 = null;
      }

      removeFeatures(rendererCode);
      meshdataLayer.legendEnabled = false;
      meshdataPgLayer.legendEnabled = false;
      loadData();

      var flagFiltering = document.getElementById("chkboxFiltering");
      
      document.getElementById("exportFileNameText").value = document.getElementById("maptitle").value;
      
      var minX = meshData[0].LONGITUDE;
      var minY = meshData[0].LATITUDE;
      var maxX = meshData[0].LONGITUDE;
      var maxY = meshData[0].LATITUDE;
      
      if (rendererCode < 8) {
        meshdataLayer.title = document.getElementById("maptitle").value;
        meshdataLayer.refresh();
        
        var vfieldName = fieldNames[valueFieldNum];
        if (nzFieldNum != -1) {
          var nzfieldName = fieldNames[nzFieldNum];
          meshdataLayer.popupTemplate = {
            title: "MESHCODE: {Meshcode}",
            content: vfieldName + ": {Value}<br>" + nzfieldName + ": {Nzvalue}",
            actions: [{title: POPUP_GETADDRESS_BTN, id: "get-address", className: "esri-icon-search"}]
          };
        } else {
          meshdataLayer.popupTemplate = {
            title: "MESHCODE: {Meshcode}",
            content: vfieldName + ": {Value}",
            actions: [{title: POPUP_GETADDRESS_BTN, id: "get-address", className: "esri-icon-search"}]
          };
        }
        
        var graphics = [];
        var graphic;
        for (var n=0; n<meshData.length; n++){
          graphic = new Graphic({
            geometry: {
              type: "point",
              latitude: meshData[n].LATITUDE,
              longitude: meshData[n].LONGITUDE,
            },
            attributes: meshData[n]
          });
          graphics.push(graphic);
          if (minX > meshData[n].LONGITUDE) minX = meshData[n].LONGITUDE;
          if (maxX < meshData[n].LONGITUDE) maxX = meshData[n].LONGITUDE;
          if (minY > meshData[n].LATITUDE) minY = meshData[n].LATITUDE;
          if (maxY < meshData[n].LATITUDE) maxY = meshData[n].LATITUDE;
        }
        
        var tkyflag = document.getElementById("tkycoordinatesystems");
        if (tkyflag.checked) {
          // tky -> jgd
          projection.load().then(function() {
            var outSR = new SpatialReference({ wkid: 4326 });
            var inSR = new SpatialReference({ wkid: 4301 });
            var trans = projection.getTransformation(inSR, outSR);
            graphics.forEach(function(graphic) {
              graphic.geometry.spatialReference = inSR;
              graphic.geometry = projection.project(graphic.geometry, outSR, trans);
              graphic.attributes.LONGITUDE = graphic.geometry.x;
              graphic.attributes.LATITUDE = graphic.geometry.y;
            });
          
            const addEdits = {
              addFeatures: graphics
            };
      
            applyEditsToLayer(addEdits, rendererCode);
            meshdataLayer.legendEnabled = true;
            meshdataLayer.refresh();
          });
        } else {
          const addEdits = {
            addFeatures: graphics
          };
      
          applyEditsToLayer(addEdits, rendererCode);
          meshdataLayer.legendEnabled = true;
          meshdataLayer.refresh();
        }
        
      } else {
        meshdataPgLayer.title = document.getElementById("maptitle").value;
        meshdataPgLayer.refresh();

      
        var vfieldName = fieldNames[valueFieldNum];
        if (nzFieldNum != -1) {
          var nzfieldName = fieldNames[nzFieldNum];
          meshdataPgLayer.popupTemplate = {
            title: "MESHCODE: {Meshcode}",
            content: vfieldName.trim() + ": {Value}<br>" + nzfieldName.trim() + ": {Nzvalue}",
            actions: [{title: POPUP_GETADDRESS_BTN, id: "get-address", className: "esri-icon-search"}]
          };
        } else {
          meshdataPgLayer.popupTemplate = {
            title: "MESHCODE: {Meshcode}",
            content: vfieldName.trim() + ": {Value}",
            actions: [{title: POPUP_GETADDRESS_BTN, id: "get-address", className: "esri-icon-search"}]
          };
        }
        
        var graphics = [];
        var graphic;
        for (var n=0; n<meshData.length; n++){
          x1 = meshData[n].LONGITUDE - meshSize[meshType][0];
          y1 = meshData[n].LATITUDE + meshSize[meshType][1];
          x2 = meshData[n].LONGITUDE + meshSize[meshType][0];
          y2 = meshData[n].LATITUDE + meshSize[meshType][1];
          x3 = meshData[n].LONGITUDE + meshSize[meshType][0];
          y3 = meshData[n].LATITUDE - meshSize[meshType][1];
          x4 = meshData[n].LONGITUDE - meshSize[meshType][0];
          y4 = meshData[n].LATITUDE - meshSize[meshType][1];
          graphic = new Graphic({
            geometry: {
              type: "polygon",
              rings: [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]
            },
            attributes: meshData[n]
          });
          graphics.push(graphic);
          if (minX > meshData[n].LONGITUDE) minX = meshData[n].LONGITUDE;
          if (maxX < meshData[n].LONGITUDE) maxX = meshData[n].LONGITUDE;
          if (minY > meshData[n].LATITUDE) minY = meshData[n].LATITUDE;
          if (maxY < meshData[n].LATITUDE) maxY = meshData[n].LATITUDE;
        }
      
        var tkyflag = document.getElementById("tkycoordinatesystems");
        if (tkyflag.checked) {
          // tky -> jgd
          projection.load().then(function() {
            var outSR = new SpatialReference({ wkid: 4326 });
            var inSR = new SpatialReference({ wkid: 4301 });
            var trans = projection.getTransformation(inSR, outSR);
            graphics.forEach(function(graphic) {
              graphic.geometry.spatialReference = inSR;
              graphic.geometry = projection.project(graphic.geometry, outSR, trans);
              graphic.attributes.LONGITUDE = graphic.geometry.extent.center.x;
              graphic.attributes.LATITUDE = graphic.geometry.extent.center.y;
            });

            const addEdits = {
              addFeatures: graphics
            };
      
            applyEditsToLayer(addEdits, rendererCode);
            meshdataPgLayer.legendEnabled = true;
            meshdataPgLayer.refresh();
          });
        } else {
          const addEdits = {
            addFeatures: graphics
          };
      
          applyEditsToLayer(addEdits, rendererCode);
          meshdataPgLayer.legendEnabled = true;
          meshdataPgLayer.refresh();
        }
      }
      document.getElementById("messagezone").style.color = "";
      document.getElementById("messagezone").innerText = featuresLoaded.toString() + MESSAGE_FEATURESLOADED;
      var centX = (maxX + minX) / 2.0;
      var centY = (maxY + minY) / 2.0;
      var targetPolygon = {
        type: "polygon",
        rings: [
          [minX, minY, 0],
          [minX, maxY, 0],
          [maxX, maxY, 0],
          [maxX, minY, 0],
          [minX, minY, 0]
        ]
      };
      var targetGraphic = new Graphic ({
        geometry: targetPolygon
      });
      view.goTo({ target: targetGraphic });
    }
    
    function removeFeatures(renderer){
      meshdataLayer.definitionExpression = '';
      meshdataLayer.queryFeatures().then(function(results){
        const deleteEdits = {
          deleteFeatures: results.features
        };
        applyEditsToLayer(deleteEdits, 0);
      });
      meshdataPgLayer.definitionExpression = '';
      meshdataPgLayer.queryFeatures().then(function(results){
        const deleteEdits = {
          deleteFeatures: results.features
        };
        applyEditsToLayer(deleteEdits, 8);
      });
    }
    
    function applyEditsToLayer(edits, renderercode) {
      if (renderercode < 8) {
        meshdataLayer
          .applyEdits(edits)
          .then(function(results) {
            if (results.addFeatureResults.length > 0){
              var objectIds = [];
              results.addFeatureResults.forEach(function(item) {
                objectIds.push(item.objectId);
              });
              meshdataLayer
                .queryFeatures({
                  objectIds: objectIds
                });
              var sizeParams = selectRenderer(renderercode);
              let rendererResult = null;
            
              if (renderercode < 4) { // size
                sizeRendererCreator
                  .createClassBreaksRenderer(sizeParams)
                  .then(function(response) {
                    rendererResult = response;
                    meshdataLayer.renderer = response.renderer;
                    updateSizeSlider(rendererResult, sizeParams);
                  })
                  .catch(function(error) {
                    console.log(error);
                  });
              } else { // color
                colorRendererCreator
                  .createClassBreaksRenderer(sizeParams)
                  .then(function(response) {
                    rendererResult = response;
                    meshdataLayer.renderer = response.renderer;
                    updateColorSlider(rendererResult, sizeParams);
                  })
                  .catch(function(error) {
                    console.log(error);
                  });
              }
            
            }
          })
          .catch(function(error) {
            console.log(error);
          });
      } else if (renderercode == 12) {
        // 3D extrude
        meshdataPgLayer
          .applyEdits(edits)
          .then(function(results) {
            if (results.addFeatureResults.length > 0){
              var objectIds = [];
              results.addFeatureResults.forEach(function(item) {
                objectIds.push(item.objectId);
              });
              meshdataPgLayer
                .queryFeatures({
                  objectIds: objectIds
                });
            
              var sizeParams = selectRenderer(renderercode);
              let rendererResult = null;
              
              colorRendererCreator.createContinuousRenderer(sizeParams)
                .then(function(response) {
                  rendererResult = response;
                  var vVar = rendererResult.visualVariable;
                  
                  var vfieldName = fieldNames[valueFieldNum];
                  if (nzFieldNum != -1){
                    // size => normalizationField max min
                    var nzfieldName = fieldNames[nzFieldNum];
                    renderer3d = {
                      type: "simple",
                      symbol: { type: "polygon-3d", symbolLayers: [{ type: "extrude" }]},
                      visualVariables: [
                        {
                          type: "size",
                          field: "Nzvalue",
                          legendOptions: { title: nzfieldName.trim() },
                          stops: [
                            {
                              value: nzValueMin,
                              size: 1,
                              label: nzValueMin.toString()
                            },
                            {
                              value: nzValueMax,
                              size: 5000,
                              label: nzValueMax.toString()
                            }
                          ]
                        },
                        {
                          type: "color",
                          field: "Value",
                          normalizationField: "Nzvalue",
                          legendOptions: { title: vfieldName.trim() + " / " + nzfieldName.trim() },
                          stops: [
                            {
                              value: vVar.stops[0].value,
                              color: vVar.stops[0].color,
                              label: vVar.stops[0].label
                            },
                            {
                              value: vVar.stops[4].value,
                              color: vVar.stops[4].color,
                              label: vVar.stops[4].label
                            }
                          ]
                        }
                      ]
                    };
                  } else {
                    // size => valuefield value
                    renderer3d = {
                      type: "simple",
                      symbol: { type: "polygon-3d", symbolLayers: [{ type: "extrude" }]},
                      visualVariables: [
                        {
                          type: "size",
                          field: "Value",
                          legendOptions: { title: vfieldName.trim() },
                          stops: [
                            {
                              value: valueMin,
                              size: 1,
                              label: valueMin.toString()
                            },
                            {
                              value: valueMax,
                              size: 5000,
                              label: valueMax.toString()
                            }
                          ]
                        },
                        {
                          type: "color",
                          field: "Value",
                          normalizationField: null,
                          legendOptions: { title: vfieldName.trim() },
                          stops: [
                            {
                              value: vVar.stops[0].value,
                              color: vVar.stops[0].color,
                              label: vVar.stops[0].label
                            },
                            {
                              value: vVar.stops[4].value,
                              color: vVar.stops[4].color,
                              label: vVar.stops[4].label
                            }
                          ]
                        }
                      ]
                    };
                  }
                  meshdataPgLayer.renderer = renderer3d;
                  updateColorSlider3d(rendererResult, sizeParams);
                })
                .catch(function(error) {
                  console.log(error);
                });
            }
          })
          .catch(function(error) {
            console.log(error);
          });

      } else {
        meshdataPgLayer
          .applyEdits(edits)
          .then(function(results) {
            if (results.addFeatureResults.length > 0){
              var objectIds = [];
              results.addFeatureResults.forEach(function(item) {
                objectIds.push(item.objectId);
              });
              meshdataPgLayer
                .queryFeatures({
                  objectIds: objectIds
                });
            
              var sizeParams = selectRenderer(renderercode);
              let rendererResult = null;
              
              colorRendererCreator
                .createClassBreaksRenderer(sizeParams)
                .then(function(response) {
                  rendererResult = response;
                  meshdataPgLayer.renderer = response.renderer;
                  updateColorSlider(rendererResult, sizeParams);
                })
                .catch(function(error) {
                  console.log(error);
                });
            
            }
          })
          .catch(function(error) {
            console.log(error);
          });
      }
    }
    
    function selectRenderer(renderercode) {
      var params = {};
      var vfieldName = fieldNames[valueFieldNum];
      switch (renderercode) {
        case "0": // size equal-interval
          params = {
            layer: meshdataLayer,
            view: view,
            field: "Value",
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true,
          };
          break;
        case "1": // size natural-breaks
          params = {
            layer: meshdataLayer,
            view: view,
            field: "Value",
            classificationMethod: "natural-breaks",
            numClasses: 5,
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true
          };
          break;
        case "2": // size quantile
          params = {
            layer: meshdataLayer,
            view: view,
            field: "Value",
            classificationMethod: "quantile",
            numClasses: 5,
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true
          };
          break;
        case "3": // size standard-deviation
          params = {
            layer: meshdataLayer,
            view: view,
            field: "Value",
            classificationMethod: "standard-deviation",
            numClasses: 5,
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true
          };
          break;
        case "4": // color equal-interval
          params = {
            layer: meshdataLayer,
            view: view,
            field: "Value",
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true,
          };
          break;
        case "5": // color natural-breaks
          params = {
            layer: meshdataLayer,
            view: view,
            field: "Value",
            classificationMethod: "natural-breaks",
            numClasses: 5,
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true
          };
          break;
        case "6": // color quantile
          params = {
            layer: meshdataLayer,
            view: view,
            field: "Value",
            classificationMethod: "quantile",
            numClasses: 5,
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true
          };
          break;
        case "7": // color standard-deviation
          params = {
            layer: meshdataLayer,
            view: view,
            field: "Value",
            classificationMethod: "standard-deviation",
            numClasses: 5,
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true
          };
          break;
        case "8": // polygon equal-interval
          params = {
            layer: meshdataPgLayer,
            view: view,
            field: "Value",
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true,
          };
          break;
        case "9": // polygon natural-breaks
          params = {
            layer: meshdataPgLayer,
            view: view,
            field: "Value",
            classificationMethod: "natural-breaks",
            numClasses: 5,
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true
          };
          break;
        case "10": // polygon quantile
          params = {
            layer: meshdataPgLayer,
            view: view,
            field: "Value",
            classificationMethod: "quantile",
            numClasses: 5,
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true
          };
          break;
        case "11": // polygon standard-deviation
          params = {
            layer: meshdataPgLayer,
            view: view,
            field: "Value",
            classificationMethod: "standard-deviation",
            numClasses: 5,
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true
          };
          break;
        case "12": // polygon extrude
          params = {
            layer: meshdataPgLayer,
            view: view,
            field: "Value",
            legendOptions: {
              title: vfieldName.trim(),
            },
            outlineOptimizationEnabled: true,
          };
          break;
        default: // same as 0
          params = {
            layer: meshdataLayer,
            view: view,
            valueExpression: "$feature.VALUE",
            legendOptions: {
              title: vfieldName.trim(),
            },
            minValue: valueMin,
            maxValue: valueMax,
            outlineOptimizationEnabled: true,
            sizeOptimizationEnabled: false
          };
          break;
      }
      if (nzFieldNum != -1) {
        var nzfieldName = fieldNames[nzFieldNum];
        params["normalizationField"] = "Nzvalue";
        params["legendOptions"]["title"] = vfieldName.trim() + " / " + nzfieldName.trim();
      }
      
      
      if (cScheme) {
        if (renderercode < 8) {
          params["colorScheme"] = colorSchemes.getSchemeByName({
            basemap: map.basemap,
            geometryType: "point",
            theme: "high-to-low",
            name: cScheme
          });
        } else {
          params["colorScheme"] = colorSchemes.getSchemeByName({
            basemap: map.basemap,
            geometryType: "polygon",
            theme: "high-to-low",
            name: cScheme
          });
        }
      }
      return params;
    }
    
    function updateSizeSlider(rendererResult, params) {
      histogram({
        layer: params.layer,
        field: params.field,
        normalizationField: params.normalizationField,
        view: view,
        numBins: 100
      }).then(function(histogramResult) {
        if(!sSlider){
          const sliderContainer = document.createElement("div");
          const container = document.createElement("div");
          container.id = "sizeSliderDiv";
          container.width = "300px";
          container.appendChild(sliderContainer);
          view.ui.add(container, "top-right");
          
          sSlider = ClassedSizeSlider.fromRendererResult(rendererResult, histogramResult);
          sSlider.container = container;
          sSlider.viewModel.precision = 2;
          
          function changeEventHandler(){
            const renderer = params.layer.renderer.clone();
            renderer.classBreakInfos = sSlider.updateClassBreakInfos(renderer.classBreakInfos);
            params.layer.renderer = renderer;
          }
          
          sSlider.on(["thumb-change", "thumb-drag", "min-change", "max-change"], 
            changeEventHandler);
        } else {
          sSlider.updateFromRendererResult(rendererResult, histogramResult);
        }
      });
    }
    
    function updateColorSlider(rendererResult, params) {
      histogram({
        layer: params.layer,
        field: params.field,
        normalizationField: params.normalizationField,
        view: view,
        numBins: 100
      }).then(function(histogramResult) {
        if(!cSlider){
          const sliderContainer = document.createElement("div");
          const container = document.createElement("div");
          container.id = "colorSliderDiv";
          container.width = "300px";
          container.appendChild(sliderContainer);
          view.ui.add(container, "top-right");
          
          cSlider = ClassedColorSlider.fromRendererResult(rendererResult, histogramResult);
          cSlider.container = container;
          cSlider.viewModel.precision = 2;
          
          function changeEventHandler(){
            const renderer = params.layer.renderer.clone();
            renderer.classBreakInfos = cSlider.updateClassBreakInfos(renderer.classBreakInfos);
            params.layer.renderer = renderer;
          }
          
          cSlider.on(["thumb-change", "thumb-drag", "min-change", "max-change"], 
            changeEventHandler);
        } else {
          cSlider.updateFromRendererResult(rendererResult, histogramResult);
        }
      });
    }
    
    function updateColorSlider3d(rendererResult, params) {
      histogram({
        layer: params.layer,
        field: params.field,
        normalizationField: params.normalizationField,
        view: view,
        numBins: 100
      }).then(function(histogramResult) {
        if(!cSlider3d){
          const sliderContainer = document.createElement("div");
          const container = document.createElement("div");
          container.id = "colorSlider3dDiv";
          container.width = "300px";
          container.appendChild(sliderContainer);
          view.ui.add(container, "top-right");
          
          cSlider3d = ColorSlider.fromRendererResult(rendererResult, histogramResult);
          cSlider3d.container = container;
          cSlider3d.viewModel.precision = 2;
          
          cSlider3d.on(["thumb-change", "thumb-drag"], function() {
            const renderer = params.layer.renderer.clone();
            const colorVariable = renderer.visualVariables[1].clone();
            renderer.visualVariables[1].stops[0] = cSlider3d.stops[0];
            renderer.visualVariables[1].stops[1] = cSlider3d.stops[4];
            params.layer.renderer = renderer;
            
          });
          cSlider3d.on(["min-change", "max-change"], function() {
            var cSlider3dMax = cSlider3d.max;
            var cSlider3dMin = cSlider3d.min;
            if (nzFieldNum != -1){
              params.layer.definitionExpression = "(Value / Nzvalue) >= " + cSlider3dMin.toString() + " AND (Value / Nzvalue) <= " + cSlider3dMax.toString();
            } else {
              params.layer.definitionExpression = "Value >= " + cSlider3dMin.toString() + " AND Value <= " + cSlider3dMax.toString();
            }
            const renderer = params.layer.renderer.clone();
            const colorVariable = renderer.visualVariables[1].clone();
            renderer.visualVariables[1].stops[0] = cSlider3d.stops[0];
            renderer.visualVariables[1].stops[1] = cSlider3d.stops[4];
            params.layer.renderer = renderer;
            params.layer.refresh();
          });
        } else {
          cSlider3d.updateFromRendererResult(rendererResult, histogramResult);
        }
      });
    }

    function refreshColorRamps() {
      var cRampDiv = document.getElementById("colorRampSelector");
      document.getElementById("selectedColorRamp").innerHTML = '';
      cRampDiv.innerHTML = '';
      cScheme = null;
      const cRamps = colorRamps.byTag({ includedTags: ["sequential", "colorblind-friendly"]});
      cRamps.forEach( ramp => {
        var cSchemeCheck = colorSchemes.getSchemeByName({
          geometryType: "point",
          theme: "high-to-low",
          basemap: map.basemap,
          name: ramp.name
        });
        if (cSchemeCheck != null) {
          const colorRampHTML = symbolUtils.renderColorRampPreviewHTML(ramp.colors, { align: "horizontal", width: 266, height: 16 });
          colorRampHTML.setAttribute("style", "height: 16px; margin-top: 1px;");
          colorRampHTML.onclick = function() {
            cScheme = ramp.name;
            var canvas0 = this.getElementsByTagName("canvas")[0];
            var canvas1 = document.createElement("canvas");
            canvas1.width = canvas0.width;
            canvas1.height = canvas0.height;
            var context0 = canvas0.getContext('2d');
            var image0 = context0.getImageData(0, 0, canvas0.width, canvas0.height);
            canvas1.getContext('2d').putImageData(image0, 0, 0);
            document.getElementById("selectedColorRamp").innerHTML = '';
            document.getElementById("selectedColorRamp").appendChild(canvas1);
          };
          cRampDiv.appendChild(colorRampHTML);
        }
      });
    }
    
    function compositScreenshotImage() {
      view.takeScreenshot().then(function(screenshot) {
        var imgData1 = screenshot.data;
        var canvasMainImage = document.createElement("canvas");
        canvasMainImage.height = imgData1.height;
        canvasMainImage.width = imgData1.width;
        var context1 = canvasMainImage.getContext("2d");
        context1.putImageData(imgData1, 0, 0);
        
        html2canvas(document.getElementById("attributionDiv")).then(function(canvas) {
          context1.drawImage(canvas, 0, canvasMainImage.height - canvas.height, canvas.width, canvas.height);
          html2canvas(document.getElementById("legendDiv")).then(function(canvas2) {
            context1.drawImage(canvas2, 0, canvasMainImage.height - canvas2.height - canvas.height, canvas2.width, canvas2.height);
            var dataUrl = canvasMainImage.toDataURL("image/png");
            var aElem = document.createElement("a");
            aElem.href = dataUrl;
            aElem.style.display = "none";
            aElem.download = "screenshot";
            document.body.appendChild(aElem);
            aElem.click();
            document.body.removeChild(aElem);
          });
        });
      });
    }
    
    
    
    
    
});




if (window.File) {
  document.getElementById("dropcsv").addEventListener("drop", function(event) { loadMappingFile(event, "drop"); }, false);
  document.getElementById("dropcsv1").addEventListener("drop", function(event) { loadJoinFile(event, "drop", 1); }, false);
  document.getElementById("dropcsv2").addEventListener("drop", function(event) { loadJoinFile(event, "drop", 2); }, false);
} else {
  alert(FILEAPIERRORMESSAGE);
}


function loadData() {
  // rawData -> meshData
  meshData = [];
  meshcodeIndex = new Array();
  meshcodeFieldNum = document.getElementById("fieldlist1").value;
  valueFieldNum = document.getElementById("fieldlist2").value;
  valueMin = Number.MAX_SAFE_INTEGER;
  valueMax = Number.MIN_SAFE_INTEGER;
  nzValueMin = Number.MAX_SAFE_INTEGER;
  nzValueMax = Number.MIN_SAFE_INTEGER;
  
  nzFieldNum = document.getElementById("fieldlist3").value;

  var flagFiltering = document.getElementById("chkboxFiltering");
  var flagFilteringNz = document.getElementById("chkboxFilteringNz");
  
  var fcount = 0;
  
  for (var j=1; j<rawData.length; j++){
    var row = rawData[j].split(/,/);
    // calculate lat/lon from meshcode
    
    if (row[meshcodeFieldNum].length >= 8 && parseInt(row[meshcodeFieldNum], 10) > 0) { // more than 8 digits and non-negative
      var latlon = latlonFromMeshcode(row[meshcodeFieldNum]);
      var lonx, laty;
      lonx = latlon.x;
      laty = latlon.y;
      meshcodeIndex[row[meshcodeFieldNum]] = j;

      var meshvalue = parseFloat(delQuo(row[valueFieldNum]));
      if (nzFieldNum != -1) {
        var nzvalue = parseFloat(delQuo(row[nzFieldNum]));
        if (flagFiltering && filteringSliderObject.disabled == false && 
            flagFilteringNz && filteringSliderObjectNz.disabled == false) {
          if (filteringCheckNZ(meshvalue, nzvalue, filteringSliderObject.values[0], filteringSliderObject.values[1]) &&
              filteringCheck(nzvalue, filteringSliderObjectNz.values[0], filteringSliderObjectNz.values[1])) {
            meshData.push({
                    LATITUDE: laty,
                    LONGITUDE: lonx,
                    MESHCODE: delQuo(row[meshcodeFieldNum].toString()),
                    VALUE: meshvalue,
                    NZVALUE: nzvalue
            });
            if (nzValueMin > nzvalue) nzValueMin = nzvalue;
            if (nzValueMax < nzvalue) nzValueMax = nzvalue;
            if (valueMin > meshvalue) valueMin = meshvalue;
            if (valueMax < meshvalue) valueMax = meshvalue;
            fcount++;
          }
        } else if (flagFiltering && filteringSliderObject.disabled == false) {
          if (filteringCheckNZ(meshvalue, nzvalue, filteringSliderObject.values[0], filteringSliderObject.values[1])) {
            meshData.push({
                    LATITUDE: laty,
                    LONGITUDE: lonx,
                    MESHCODE: delQuo(row[meshcodeFieldNum].toString()),
                    VALUE: meshvalue,
                    NZVALUE: nzvalue
            });
            if (nzValueMin > nzvalue) nzValueMin = nzvalue;
            if (nzValueMax < nzvalue) nzValueMax = nzvalue;
            if (valueMin > meshvalue) valueMin = meshvalue;
            if (valueMax < meshvalue) valueMax = meshvalue;
            fcount++;
          }
        } else {
          meshData.push({
                  LATITUDE: laty,
                  LONGITUDE: lonx,
                  MESHCODE: delQuo(row[meshcodeFieldNum].toString()),
                  VALUE: meshvalue,
                  NZVALUE: nzvalue
          });
          if (nzValueMin > nzvalue) nzValueMin = nzvalue;
          if (nzValueMax < nzvalue) nzValueMax = nzvalue;
          if (valueMin > meshvalue) valueMin = meshvalue;
          if (valueMax < meshvalue) valueMax = meshvalue;
          fcount++;
        }
      } else {
        if (flagFiltering && filteringSliderObject.disabled == false) {
          if (filteringCheck(meshvalue, filteringSliderObject.values[0], filteringSliderObject.values[1])) {
            meshData.push({
                    LATITUDE: laty,
                    LONGITUDE: lonx,
                    MESHCODE: delQuo(row[meshcodeFieldNum].toString()),
                    VALUE: meshvalue,
                    NZVALUE: 0
            });
            if (valueMin > meshvalue) valueMin = meshvalue;
            if (valueMax < meshvalue) valueMax = meshvalue;
            fcount++;
          }
        } else {
          meshData.push({
                  LATITUDE: laty,
                  LONGITUDE: lonx,
                  MESHCODE: delQuo(row[meshcodeFieldNum].toString()),
                  VALUE: meshvalue,
                  NZVALUE: 0
          });
          if (valueMin > meshvalue) valueMin = meshvalue;
          if (valueMax < meshvalue) valueMax = meshvalue;
          fcount++;
        }
      }
      featuresLoaded = fcount;
    }
  }
}

function filteringCheck(value, min, max) {
  if (value >= min && value <= max) {
    return true;
  } else {
    return false;
  }
}

function filteringCheckNZ(value, nzvalue, min, max) {
  if (nzvalue != 0) {
    if (value / nzvalue >= min && value / nzvalue <= max) {
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
}


function fieldRefresh() {
  if (rawData.length > 0) {
    var estatflag = document.getElementById("estatdata");
    var colnameRow = 0;
    if (estatflag.checked) {
      // field name in 2nd row
      colnameRow = 1;
    } else {
      // field name in 1st row
      colnameRow = 0;
    }

    let fieldList1 = document.getElementById("fieldlist1");
    let fieldList2 = document.getElementById("fieldlist2");
    let fieldList3 = document.getElementById("fieldlist3");
  
    while (fieldList1.firstChild){ fieldList1.removeChild(fieldList1.firstChild); }
    while (fieldList2.firstChild){ fieldList2.removeChild(fieldList2.firstChild); }
    while (fieldList3.firstChild){ fieldList3.removeChild(fieldList3.firstChild); }
  
    let nulloption = document.createElement('option');
    nulloption.setAttribute('value', -1);
    nulloption.innerHTML = "----";
    fieldList3.appendChild(nulloption);
    var colNames = rawData[colnameRow].split(/,/);
    fieldNames = rawData[colnameRow].split(/,/);
    for (var k=0; k<colNames.length; k++) {
      if (colNames[k] == "") {
        colNames[k] = rawData[0].split(/,/)[k];
        fieldNames[k] = colNames[k];
      }
      let option1 = document.createElement('option');
      option1.setAttribute('value', k);
      option1.innerHTML = colNames[k].substr(0,18);
      fieldList1.appendChild(option1);
      let option2 = document.createElement('option');
      option2.setAttribute('value', k);
      option2.innerHTML = colNames[k].substr(0,18);
      fieldList2.appendChild(option2);
      let option3 = document.createElement('option');
      option3.setAttribute('value', k);
      option3.innerHTML = colNames[k].substr(0,18);
      fieldList3.appendChild(option3);
    }

    // set default field
    meshcodeFieldNum = 0;
    valueFieldNum = 1;
    nzFieldNum = 0; // -1 means not selected
  
    fieldList1.options[meshcodeFieldNum].selected = true;
    fieldList2.options[valueFieldNum].selected = true;
    fieldList3.options[nzFieldNum].selected = true;
  }
}

function loadMappingFile(event, mode) {   // old name onDrop
  var files;
  if (mode == "drop") {
    files = event.dataTransfer.files;
    event.preventDefault();
  } else if (mode == "select") {
    var fileElem = document.getElementById("selectcsv");
    files = fileElem.files;
  }

  var addflag = document.getElementById("adddata");
  
  if (!addflag.checked) {
    rawData = [];
  }
  clearActionPanelSettings();
  clearActionPanelSettingsNz();
  
  for (var i=0; i<files.length; i++){
    var f = files[i];
    var reader = new FileReader();
    
    if (f.name.match(/csv$/m) || f.name.match(/txt$/m)) {
      reader.onload = function (evt) {
        // file loaded
        document.getElementById("displayedfilename").innerText = f.name;
        var rows = evt.target.result.split(/\n/);
        var colNames = rows[0].split(/,/); // col names
        fieldNames = rows[0].split(/,/);
        fileName = f.name;
        if (addflag.checked) {
          var rawDataRow0 = rawData[0];
          var colCount = rawDataRow0.split(/,/).length;
          if (colCount == colNames.length) {
            var addData = evt.target.result.split(/\n/);
            rawData = rawData.concat(addData);
          } else {
            rawData = evt.target.result.split(/\n/);
          }
        } else if (files.length > 1 && rawData.length != 0) {
          var rawDataRow0 = rawData[0];
          var colCount = rawDataRow0.split(/,/).length;
          if (colCount == colNames.length) {
            var addData = evt.target.result.split(/\n/);
            rawData = rawData.concat(addData);
          } else {
            rawData = evt.target.result.split(/\n/);
          }
        } else {
          rawData = evt.target.result.split(/\n/);
        }
        document.getElementById("numofrecords").innerText = rawData.length.toString();
        document.getElementById("numoffields").innerText = colNames.length.toString();
        document.getElementById("estatdata").checked = false;
        
        // predict data title
        var titlestr = "";
        if (fileName.match(/_/)) {
          var temparray = fileName.split(/_/);
          for (var m=0; m<temparray.length; m++){
            if (temparray[m].length != encodeURI(temparray[m]).replace(/%../g,"x").length) {
              titlestr = temparray[m];
              break;
            }
          }
        }
        
        if (titlestr == "") titlestr = fileName.substr(0, 10);
        document.getElementById("maptitle").value = titlestr;
        
        let fieldList1 = document.getElementById("fieldlist1");
        let fieldList2 = document.getElementById("fieldlist2");
        let fieldList3 = document.getElementById("fieldlist3");
        
        while (fieldList1.firstChild){ fieldList1.removeChild(fieldList1.firstChild); }
        while (fieldList2.firstChild){ fieldList2.removeChild(fieldList2.firstChild); }
        while (fieldList3.firstChild){ fieldList3.removeChild(fieldList3.firstChild); }
        
        let nulloption = document.createElement('option');
        nulloption.setAttribute('value', -1);
        nulloption.innerHTML = "----";
        fieldList3.appendChild(nulloption);
        
        for (var k=0; k<colNames.length; k++) {
          let option1 = document.createElement('option');
          option1.setAttribute('value', k);
          option1.innerHTML = colNames[k].substr(0,16);
          fieldList1.appendChild(option1);
          let option2 = document.createElement('option');
          option2.setAttribute('value', k);
          option2.innerHTML = colNames[k].substr(0,16);
          fieldList2.appendChild(option2);
          let option3 = document.createElement('option');
          option3.setAttribute('value', k);
          option3.innerHTML = colNames[k].substr(0,16);
          fieldList3.appendChild(option3);
        }
        
        // set default field
        meshcodeFieldNum = 0;
        valueFieldNum = 1;
        nzFieldNum = 0; // -1 means not selected
        
        fieldList1.options[meshcodeFieldNum].selected = true;
        fieldList2.options[valueFieldNum].selected = true;
        fieldList3.options[nzFieldNum].selected = true;
        
      }
      reader.readAsText(f, 'sjis');
    }
    
  }
  event.preventDefault();
}

function adddataCheck() {
  var addflag0 = document.getElementById("adddata");
  if (addflag0.checked) {
    if (rawData.length == 0) {
      addflag0.checked = false;
    }
  }
}

function selectRenderingMethod() {
  var rendererCode = document.getElementById("rmethodlist").value;
  if (rendererCode >= 4) { // color and polygon
    document.getElementById("colorOptionUI").style.display = "block";
    document.getElementById("selectedColorRamp").style.display = "block";
    document.getElementById("colorRampSelector").style.display = "block";
  } else {
    document.getElementById("colorOptionUI").style.display = "none";
    document.getElementById("selectedColorRamp").style.display = "none";
    document.getElementById("colorRampSelector").style.display = "none";
  }
  checkActionPanelSize();
}

function checkActionPanelSize() {
  var viewDiv = document.getElementById("viewDiv");
  var actDiv = document.getElementById("actions");
  if ((viewDiv.getBoundingClientRect().height - actDiv.getBoundingClientRect().height) < 60) {
    var btn = document.getElementById("closeActionPanelBtn");
    if (btn.innerText == ACTIONPANELCLOSE) {
      actDiv.style.overflowY = "scroll";
      actDiv.style.height = (viewDiv.getBoundingClientRect().height - 60).toString() + "px";
    }
  } else {
    var btn = document.getElementById("closeActionPanelBtn");
    if (btn.innerText == ACTIONPANELCLOSE) {
      actDiv.style.overflowY = "auto";
      actDiv.style.height = "";
    }
  }
}


function checkFilterFlag() {
  var flag = document.getElementById("chkboxFiltering");
  if (flag.checked) {
    document.getElementById("calcMinMaxBtn").disabled = false;
    if (calculatedMinMax) {
      filteringSliderObject.disabled = false;
      filteringSliderObject.min = valueMin;
      filteringSliderObject.max = valueMax;
      filteringSliderObject.values = [valueMin, valueMax];
    }
  } else {
    document.getElementById("calcMinMaxBtn").disabled = true;
    filteringSliderObject.disabled = true;
    var messagespan = document.getElementById("estimatefeaturecount");
    messagespan.innerText = "";
  }
}

function checkNzFilterFlag() {
  var flag = document.getElementById("chkboxFilteringNz");
  nzFieldNum = document.getElementById("fieldlist3").value;
  if (flag.checked) {
    if (nzFieldNum == -1) {
      flag.checked = false;
    } else {
      document.getElementById("calcNzMinMaxBtn").disabled = false;
      if (calculatedMinMax) {
        filteringSliderObjectNz.disabled = false;
        filteringSliderObjectNz.min = valueMin;
        filteringSliderObjectNz.max = valueMax;
        filteringSliderObjectNz.values = [valueMin, valueMax];
      }
    }
  } else {
    document.getElementById("calcNzMinMaxBtn").disabled = true;
    filteringSliderObjectNz.disabled = true;
    var messagespan = document.getElementById("estimatefeaturecount");
    messagespan.innerText = "";
  }
}


function calculateMinMaxValues() {
  // calculate min and max values for filtering Slider
  if (rawData.length > 0) {
    // calculate
    valueFieldNum = document.getElementById("fieldlist2").value;
    valueMin = Number.MAX_SAFE_INTEGER;
    valueMax = Number.MIN_SAFE_INTEGER;
    var normalizedValueMin = Number.MAX_VALUE;
    var normalizedValueMax = Number.MIN_VALUE;
    nzFieldNum = document.getElementById("fieldlist3").value;
  
    for (var j=1; j<rawData.length; j++){
      var row = rawData[j].split(/,/);
      var meshvalue = parseFloat(delQuo(row[valueFieldNum]));
      if (nzFieldNum != -1) {
        var nzvalue = parseFloat(delQuo(row[nzFieldNum]));
        if (nzvalue > 0) {
          var normalizeValue = meshvalue / nzvalue;
          if (normalizedValueMin > normalizeValue) normalizedValueMin = normalizeValue;
          if (normalizedValueMax < normalizeValue) normalizedValueMax = normalizeValue;
        }
      }
      if (valueMin > meshvalue) valueMin = meshvalue;
      if (valueMax < meshvalue) valueMax = meshvalue;
    }
    
    filteringSliderObject.disabled = false;
    if (nzFieldNum != -1){
      filteringSliderObject.min = normalizedValueMin;
      filteringSliderObject.max = normalizedValueMax;
      filteringSliderObject.values = [normalizedValueMin, normalizedValueMax];
    } else {
      filteringSliderObject.min = valueMin;
      filteringSliderObject.max = valueMax;
      filteringSliderObject.values = [valueMin, valueMax];
    }
    var estFeaturesCount = estimateLoadingFeatures();
    var messagespan = document.getElementById("estimatefeaturecount");
    messagespan.innerText = estFeaturesCount.toString() + MESSAGE_FEATURESWILLBELOADED;
  } else {
    alert(ALERTNODATA);
  }
}

function calculateNzMinMaxValues() {
  // calculate min and max normalization values for filtering Slider
  if (rawData.length > 0 && nzFieldNum != -1) {
    // calculate
    valueFieldNum = document.getElementById("fieldlist2").value;
    valueMin = Number.MAX_SAFE_INTEGER;
    valueMax = Number.MIN_SAFE_INTEGER;

    nzValueMin = Number.MAX_SAFE_INTEGER;
    nzValueMax = Number.MIN_SAFE_INTEGER;

    nzFieldNum = document.getElementById("fieldlist3").value;
  
    for (var j=1; j<rawData.length; j++){
      var row = rawData[j].split(/,/);
      var nzvalue = parseFloat(delQuo(row[nzFieldNum]));
      if (nzvalue > 0) {
        if (nzValueMin > nzvalue) nzValueMin = nzvalue;
        if (nzValueMax < nzvalue) nzValueMax = nzvalue;
      }
    }
    
    filteringSliderObjectNz.disabled = false;
    filteringSliderObjectNz.min = nzValueMin;
    filteringSliderObjectNz.max = nzValueMax;
    filteringSliderObjectNz.values = [nzValueMin, nzValueMax];
    var estFeaturesCount = estimateLoadingFeatures();
    var messagespan = document.getElementById("estimatefeaturecount");
    messagespan.innerText = estFeaturesCount.toString() + MESSAGE_FEATURESWILLBELOADED;
  } else {
    alert(ALERTNODATA);
  }
}



function estimateLoadingFeatures() {
  var fcount = 0;
  meshcodeFieldNum = document.getElementById("fieldlist1").value;
  valueFieldNum = document.getElementById("fieldlist2").value;
  nzFieldNum = document.getElementById("fieldlist3").value;
  var flagFiltering = document.getElementById("chkboxFiltering");
  var flagFilteringNz = document.getElementById("chkboxFilteringNz");
  
  for (var j=1; j<rawData.length; j++){
    var row = rawData[j].split(/,/);
    if (delQuo(row[meshcodeFieldNum]).length >= 8 && parseInt(delQuo(row[meshcodeFieldNum]), 10) > 0) { // more than 8 digits and non-negative
      var meshvalue = parseFloat(delQuo(row[valueFieldNum]));
      if (nzFieldNum != -1) {
        var nzvalue = parseFloat(delQuo(row[nzFieldNum]));
        if (flagFiltering && filteringSliderObject.disabled == false && 
            flagFilteringNz && filteringSliderObjectNz.disabled == false) {
          if (filteringCheckNZ(meshvalue, nzvalue, filteringSliderObject.values[0], filteringSliderObject.values[1]) &&
              filteringCheck(nzvalue, filteringSliderObjectNz.values[0], filteringSliderObjectNz.values[1])) {
            fcount++;
          }
        } else if (flagFiltering && filteringSliderObject.disabled == false) {
          if (filteringCheckNZ(meshvalue, nzvalue, filteringSliderObject.values[0], filteringSliderObject.values[1])) {
            fcount++;
          }
        } else {
          fcount++;
        }
      } else {
        if (flagFiltering && filteringSliderObject.disabled == false) {
          if (filteringCheck(meshvalue, filteringSliderObject.values[0], filteringSliderObject.values[1])) {
            fcount++;
          }
        } else {
          fcount++;
        }
      }
    }
  }
  return fcount;
}

function onDragOverDropBtn(event) {
  event.preventDefault();
}

function closeActionPanel() {
  var btn = document.getElementById("closeActionPanelBtn");
  var panel = document.getElementById("actions");
  var topelem = document.getElementById("dropcsv");
  if (btn.innerText == ACTIONPANELCLOSE) {
    panel.scrollTop = 0;
    panel.style.height = "42px";
    btn.className = "esri-button";
    btn.style.height = "32px";
    btn.style.marginBottom = "5px";
    panel.style.overflow = "hidden";
    btn.innerText = ACTIONPANELOPEN;
    panel.insertBefore(btn, topelem);
  } else if (btn.innerText == ACTIONPANELOPEN) {
    var viewDiv = document.getElementById("viewDiv");
    panel.style.height = "";
    panel.style.overflow = "visible";
    btn.className = "esri-button--tertiary";
    btn.innerText = ACTIONPANELCLOSE;
    btn.style.marginBottom = "";
    btn.style.height = "";
    panel.appendChild(btn);
    if ((viewDiv.getBoundingClientRect().height - panel.getBoundingClientRect().height) < 40) {
      panel.style.overflowY = "scroll";
      panel.style.height = (viewDiv.getBoundingClientRect().height - 40).toString() + "px";
    }
  }
}

function clearActionPanelSettings() {
  var flag = document.getElementById("chkboxFiltering");
  flag.checked = false;
  checkFilterFlag();
}

function clearActionPanelSettingsNz() {
  var flag = document.getElementById("chkboxFiltering");
  flag.checked = false;
  checkFilterFlag();
  var flagNz = document.getElementById("chkboxFilteringNz");
  flagNz.checked = false;
  checkNzFilterFlag();
}

function delQuo(str) {
  if (typeof str !== "undefined") {
    var str0 = str.replace(/^"/,"").replace(/"$/,"");
  } else {
    var str0 = "";
  }
  return str0;
}


function latlonFromMeshcode(meshcodestr) {
  if (meshcodestr.length >= 8 && parseInt(meshcodestr, 10) > 0) { // more than 8 digits and non-negative
    var lonx, laty;
    var m1y = parseInt(meshcodestr.substring(0,2),10) / 1.5;
    var m1x = parseInt(meshcodestr.substring(2,4),10) + 100.0;
    var m2y = parseInt(meshcodestr.substring(4,5),10) * (5.0/60.0);
    var m2x = parseInt(meshcodestr.substring(5,6),10) * (7.5/60.0);
    var m3y = parseInt(meshcodestr.substring(6,7),10) * (0.5/60.0);
    var m3x = parseInt(meshcodestr.substring(7,8),10) * (0.75/60.0);
    
    lonx = m1x + m2x + m3x;
    laty = m1y + m2y + m3y;
    if (meshcodestr.length == 8) { // 8 digits 3ji mesh
      meshType = "tertiary";
      lonx = lonx + meshSize[meshType][0];
      laty = laty + meshSize[meshType][1];
    } else if (meshcodestr.length == 9) { // 9 digits 4ji mesh
      meshType = "quaternary";
      switch (meshcodestr.substring(8,9)) {
        case "1":
          lonx = lonx + meshSize[meshType][0];
          laty = laty + meshSize[meshType][1];
          break;
        case "2":
          lonx = lonx + (22.5 / 3600.0) + meshSize[meshType][0];
          laty = laty + meshSize[meshType][1];
          break;
        case "3":
          lonx = lonx + meshSize[meshType][0];
          laty = laty + (15.0 / 3600.0) + meshSize[meshType][1];
          break;
        case "4":
          lonx = lonx + (22.5 / 3600.0) + meshSize[meshType][0];
          laty = laty + (15.0 / 3600.0) + meshSize[meshType][1];
          break;
      }
    } else if (meshcodestr.length == 10) { // 10 digits 5ji mesh
      meshType = "quinary";
      switch (meshcodestr.substring(8,9)) {
        case "1":
          lonx = lonx + meshSize[meshType][0];
          laty = laty + meshSize[meshType][1];
          break;
        case "2":
          lonx = lonx + (22.5 / 3600.0) + meshSize[meshType][0];
          laty = laty + meshSize[meshType][1];
          break;
        case "3":
          lonx = lonx + meshSize[meshType][0];
          laty = laty + (15.0 / 3600.0) + meshSize[meshType][1];
          break;
        case "4":
          lonx = lonx + (22.5 / 3600.0) + meshSize[meshType][0];
          laty = laty + (15.0 / 3600.0) + meshSize[meshType][1];
          break;
      }
      switch (meshcodestr.substring(9,10)) {
        case "1":
          lonx = lonx + meshSize[meshType][0];
          laty = laty + meshSize[meshType][1];
          break;
        case "2":
          lonx = lonx + (11.25 / 3600.0) + meshSize[meshType][0];
          laty = laty + meshSize[meshType][1];
          break;
        case "3":
          lonx = lonx + meshSize[meshType][0];
          laty = laty + (7.5 / 3600.0) + meshSize[meshType][1];
          break;
        case "4":
          lonx = lonx + (11.25 / 3600.0) + meshSize[meshType][0];
          laty = laty + (7.5 / 3600.0) + meshSize[meshType][1];
          break;
      }
    }
    // 11 digits 6jimesh senary (in future)
  }
  var returnVal = { "x": lonx, "y": laty };
  return returnVal;
}


function showSidePanel() {
  var spanel = document.getElementById("sidePanelDiv");
  spanel.style.display = "block";
  var spanelbtn = document.getElementById("showSidePanelBtn");
  spanelbtn.style.display = "none";
}


function hideSidePanel() {
  var spanel = document.getElementById("sidePanelDiv");
  spanel.style.display = "none";
  var spanelbtn = document.getElementById("showSidePanelBtn");
  spanelbtn.style.display = "inline";
}

function loadJoinFile(event, mode, fileNum) {
  var files;
  var f;
  if (mode == "drop") {
    files = event.dataTransfer.files;
    if (files.length > 1) {
      alert(CAUTION_CANNOT_LOAD_MULTIPLEFILES_IN_JOIN);
      return false;
    }
    event.preventDefault();
    f = files[0];
  } else if (mode == "select") {
    var elemIds = ["selectcsv1", "selectcsv2"];
    var fileElem = document.getElementById(elemIds[fileNum-1]);
    f = fileElem.files[0];
  }

  var reader = new FileReader();
  
  if (f.name.match(/csv$/m) || f.name.match(/txt$/m)) {
    var fname = f.name;
    reader.onload = function (evt) {
      // file loaded
      var rows = evt.target.result.split(/\n/);
      var colNames = rows[0].split(/,/); // col names
      var fieldListJoin;
      if (fileNum == 1) {
        joinFieldNames1 = rows[0].split(/,/);
        joinRawData1 = evt.target.result.split(/\n/);
        document.getElementById("estatdatajoin1").checked = false;
        fieldListJoin = document.getElementById("fieldlistjoin1");
      } else if (fileNum == 2) {
        joinFieldNames2 = rows[0].split(/,/);
        joinRawData2 = evt.target.result.split(/\n/);
        document.getElementById("estatdatajoin2").checked = false;
        fieldListJoin = document.getElementById("fieldlistjoin2");
      }
      
      while (fieldListJoin.firstChild){ fieldListJoin.removeChild(fieldListJoin.firstChild); }
        
      for (var k=0; k<colNames.length; k++) {
        let option1 = document.createElement('option');
        option1.setAttribute('value', k);
        option1.innerHTML = colNames[k].substr(0,16);
        fieldListJoin.appendChild(option1);
      }
        
      // set default field
      if (fileNum == 1) {
        joinMeshcodeFieldNum1 = 0;
        fieldListJoin.options[joinMeshcodeFieldNum1].selected = true;
        document.getElementById("joinfilename1").innerText = fname;
        document.getElementById("numofrecordsjoin1").innerText = joinRawData1.length.toString();
      } else if (fileNum == 2) {
        joinMeshcodeFieldNum2 = 0;
        fieldListJoin.options[joinMeshcodeFieldNum2].selected = true;
        document.getElementById("joinfilename2").innerText = fname;
        document.getElementById("numofrecordsjoin2").innerText = joinRawData2.length.toString();
      }
    }
    reader.readAsText(f, 'sjis');
  }
  event.preventDefault();
}

function fieldRefreshJoin(fileNum) {
  var estatflag;
  var fieldListJoin;
  if (fileNum == 1) {
    if (joinRawData1.length == 0) {
      return false;
    }
    estatflag = document.getElementById("estatdatajoin1");
    fieldListJoin = document.getElementById("fieldlistjoin1");
  }
  if (fileNum == 2) {
    if (joinRawData2.length == 0) {
      return false;
    }
    estatflag = document.getElementById("estatdatajoin2");
    fieldListJoin = document.getElementById("fieldlistjoin2");
  }

  var colnameRow = 0;
  if (estatflag.checked) {
    // field name in 2nd row
    colnameRow = 1;
  } else {
    // field name in 1st row
    colnameRow = 0;
  }

  while (fieldListJoin.firstChild){ fieldListJoin.removeChild(fieldListJoin.firstChild); }
  
  var colNames;
  if (fileNum == 1) {
    colNames = joinRawData1[colnameRow].split(/,/);
    joinFieldNames1 = joinRawData1[colnameRow].split(/,/);
  } else if (fileNum == 2) {
    colNames = joinRawData2[colnameRow].split(/,/);
    joinFieldNames2 = joinRawData2[colnameRow].split(/,/);
  }
  for (var k=0; k<colNames.length; k++) {
    if (colNames[k] == "") {
      if (fileNum == 1) {
        colNames[k] = joinRawData1[0].split(/,/)[k];
        joinFieldNames1[k] = colNames[k];
      } else if (fileNum == 2){
        colNames[k] = joinRawData2[0].split(/,/)[k];
        joinFieldNames2[k] = colNames[k];
      }
    }
    let option1 = document.createElement('option');
    option1.setAttribute('value', k);
    option1.innerHTML = colNames[k].substr(0,18);
    fieldListJoin.appendChild(option1);

    // set default field
    if (fileNum == 1) {
      joinMeshcodeFieldNum1 = 0;
      fieldListJoin.options[joinMeshcodeFieldNum1].selected = true;
    } else if (fileNum == 2) {
      joinMeshcodeFieldNum2 = 0;
      fieldListJoin.options[joinMeshcodeFieldNum2].selected = true;
    }
  }
}

function joinMeshData() {
  var mode = "leftouter";
  var joinMethodFlag = document.getElementById("joinMethodInner");
  if (joinMethodFlag.checked) mode = "inner";

  showMessageJoin("", "");
  if (joinRawData1.length == 0) {
    showMessageJoin(CAUTION_NOJOINDATA1, "red");
    return false;
  }
  if (joinRawData2.length == 0) {
    showMessageJoin(CAUTION_NOJOINDATA2, "red");
    return false;
  }
  
  var meshcodeIndexJoin2 = new Array();
  var startRow1 = 1;
  var startRow2 = 1;
  joinMeshcodeFieldNum1 = document.getElementById("fieldlistjoin1").value;
  joinMeshcodeFieldNum2 = document.getElementById("fieldlistjoin2").value;
  var estatflag1 = document.getElementById("estatdatajoin1");
  var estatflag2 = document.getElementById("estatdatajoin2");
  
  if (estatflag1.checked) startRow1 = 2;
  if (estatflag2.checked) startRow2 = 2;
  var joinResultData = [];
  var joinResultFieldNames = [];
  
  for (var i=0; i<joinFieldNames1.length; i++) {
    joinResultFieldNames.push(joinFieldNames1[i]);
  }
  for (var i=0; i<joinFieldNames2.length; i++) {
    if (i != joinMeshcodeFieldNum2) joinResultFieldNames.push(joinFieldNames2[i]);
  }
  
  joinResultData.push(joinResultFieldNames.join(","));
  
  for (var i=startRow2; i<joinRawData2.length; i++) {
    var row = joinRawData2[i].split(",");
    var mcode2 = row[joinMeshcodeFieldNum2];
    if (mcode2 != "") meshcodeIndexJoin2[mcode2] = i;
  }
  
  var joinedCount = 0;
  
  if (mode == "inner") {
    for (var k=startRow1; k<joinRawData1.length; k++) {
      var resultRow = "";
      var row = joinRawData1[k].split(",");
      var mcode1 = row[joinMeshcodeFieldNum1];
      if (mcode1 in meshcodeIndexJoin2) {
        resultRow += joinRawData1[k].replace("\r","").replace("\n","");
        var mcode2 = meshcodeIndexJoin2[mcode1];
        var row2 = joinRawData2[mcode2].split(",");
        for (var j=0; j<row2.length; j++) {
          if (j != joinMeshcodeFieldNum2) resultRow += "," + row2[j];
        }
        joinResultData.push(resultRow);
        joinedCount++;
      }
    }
  } else if (mode == "leftouter") {
    for (var k=startRow1; k<joinRawData1.length; k++) {
      var resultRow = "";
      var row = joinRawData1[k].split(",");
      var mcode1 = row[joinMeshcodeFieldNum1];
      resultRow += joinRawData1[k].replace("\r","").replace("\n","");
      if (mcode1 in meshcodeIndexJoin2) {
        var mcode2 = meshcodeIndexJoin2[mcode1];
        var row2 = joinRawData2[mcode2].split(",");
        for (var j=0; j<row2.length; j++) {
          if (j != joinMeshcodeFieldNum2) resultRow += "," + row2[j];
        }
        joinedCount++;
      } else {
        for (var j=0; j<joinFieldNames2.length; j++) {
          if (j != joinMeshcodeFieldNum2) resultRow += ",";
        }
      }
      joinResultData.push(resultRow);
    }
  }
  
  
  showMessageJoin(joinedCount.toString() + JOINEDMESSAGE_LOADMAPYESNO, "");
  var messDiv = document.getElementById("messagezonejoin");
  var yesMessBtn = document.createElement("button");
  yesMessBtn.classList.add("esri-button--tertiary");
  yesMessBtn.innerText = MESSAGE_YES;
  yesMessBtn.addEventListener("click", function() {
    messDiv.innerHTML = "";
    loadJoinedData(joinResultData, joinResultFieldNames);
  });
  messDiv.appendChild(yesMessBtn);
  var noMessBtn = document.createElement("button");
  noMessBtn.classList.add("esri-button--tertiary");
  noMessBtn.innerText = MESSAGE_NO;
  noMessBtn.addEventListener("click", function() {
    messDiv.innerHTML = "";
  });
  messDiv.appendChild(noMessBtn);
  
}

function showMessageJoin(message, colorname) {
  var messDiv = document.getElementById("messagezonejoin");
  messDiv.style.color = colorname;
  messDiv.innerText = message;
}

function selectFileDialog(fileNum) {
  if (fileNum == 1) document.getElementById("selectcsv1").click();
  if (fileNum == 2) document.getElementById("selectcsv2").click();
  if (fileNum == 3) document.getElementById("selectcsv").click();
}

function loadJoinedData(data, fnames) {
  var addflag = document.getElementById("adddata");
  addflag.checked = false;
  rawData = [];
  clearActionPanelSettings();
  clearActionPanelSettingsNz();
  
  var tempFileName = "joineddata.csv";
  document.getElementById("displayedfilename").innerText = tempFileName;
  var colNames = fnames;
  fieldNames = fnames;
  rawData = data;
  document.getElementById("numofrecords").innerText = rawData.length.toString();
  document.getElementById("numoffields").innerText = colNames.length.toString();
  document.getElementById("estatdata").checked = false;
  
  document.getElementById("maptitle").value = "joineddata";
  
  let fieldList1 = document.getElementById("fieldlist1");
  let fieldList2 = document.getElementById("fieldlist2");
  let fieldList3 = document.getElementById("fieldlist3");
  
  while (fieldList1.firstChild){ fieldList1.removeChild(fieldList1.firstChild); }
  while (fieldList2.firstChild){ fieldList2.removeChild(fieldList2.firstChild); }
  while (fieldList3.firstChild){ fieldList3.removeChild(fieldList3.firstChild); }
  
  let nulloption = document.createElement('option');
  nulloption.setAttribute('value', -1);
  nulloption.innerHTML = "----";
  fieldList3.appendChild(nulloption);
  
  for (var k=0; k<colNames.length; k++) {
    let option1 = document.createElement('option');
    option1.setAttribute('value', k);
    option1.innerHTML = colNames[k].substr(0,16);
    fieldList1.appendChild(option1);
    let option2 = document.createElement('option');
    option2.setAttribute('value', k);
    option2.innerHTML = colNames[k].substr(0,16);
    fieldList2.appendChild(option2);
    let option3 = document.createElement('option');
    option3.setAttribute('value', k);
    option3.innerHTML = colNames[k].substr(0,16);
    fieldList3.appendChild(option3);
  }
  
  // set default field
  meshcodeFieldNum = 0;
  valueFieldNum = 1;
  nzFieldNum = 0; // -1 means not selected
  
  fieldList1.options[meshcodeFieldNum].selected = true;
  fieldList2.options[valueFieldNum].selected = true;
  fieldList3.options[nzFieldNum].selected = true;
}

function changeExportPanel() {
  var div1 = document.getElementById("exportDivDisplayedData");
  var div2 = document.getElementById("exportDivLoadedData");
  var divselect = document.getElementById("exportTypeSelect");
  if (divselect.value == "displayeddata") {
    div1.style.display = "inline";
    div2.style.display = "none";
  } else if (divselect.value == "loadeddata") {
    div1.style.display = "none";
    div2.style.display = "inline";
  }
}



</script>
  </body>
</html>
